#import "../../Executable/MaPLGeneratorAPI.mapl"

// Determine if we need to declare an array type.
bool anySchemaUsesLists = false;
for uint32 schemaIndex = 0; !anySchemaUsesLists && schemaIndex < schemas.count; schemaIndex++ {
    Schema schema = schemas[schemaIndex];
    for uint32 classIndex = 0; !anySchemaUsesLists && classIndex < schema.classes.count; classIndex++ {
        SchemaClass class = schema.classes[classIndex];
        for uint32 attributeIndex = 0; attributeIndex < class.attributes.count; attributeIndex++ {
            SchemaAttribute attribute = class.attributes[attributeIndex];
            if (attribute.minOccurrences < 1 || attribute.maxOccurrences > 1) {
                anySchemaUsesLists = true;
                break;
            }
        }
    }
}

string outputDirectory = commandLineFlag("scriptOutputDir");

if anySchemaUsesLists {
    outputToFile(outputDirectory+"/Array.mapl");
    <?// This file was generated by MaPLGenerator.
#type Array<T> {
    T[uint32];
    readonly uint32 count;
}
#type ReadonlyArray<T> {
    readonly T[uint32];
    readonly uint32 count;
}
?>
}

for uint32 schemaIndex = 0; schemaIndex < schemas.count; schemaIndex++ {
    Schema schema = schemas[schemaIndex];
    string schemaNamespace = schema.namespace;
    outputToFile(outputDirectory+"/"+schemaNamespace+"API.mapl");
    
    <?// This file was generated by MaPLGenerator, based on the '${schemaNamespace}' schema.

?>

    bool thisSchemaUsesLists = false;
    for uint32 classIndex = 0; !thisSchemaUsesLists && classIndex < schema.classes.count; classIndex++ {
        SchemaClass class = schema.classes[classIndex];
        for uint32 attributeIndex = 0; attributeIndex < class.attributes.count; attributeIndex++ {
            SchemaAttribute attribute = class.attributes[attributeIndex];
            if (attribute.minOccurrences < 1 || attribute.maxOccurrences > 1) {
                thisSchemaUsesLists = true;
                break;
            }
        }
    }
    if thisSchemaUsesLists {
        <?#import "./Array.mapl"

?>
    }
    
    if schema.enums.count > 0 {
        <?// Enums.
?>
        for uint32 enumIndex = 0; enumIndex < schema.enums.count; enumIndex++ {
            SchemaEnum enum = schema.enums[enumIndex];
            string enumName = enum.name;
            for uint32 enumCaseIndex = 0; enumCaseIndex < enum.cases.count; enumCaseIndex++ {
                <?#global readonly uint32 ${schemaNamespace}_${enumName}_${enum.cases[enumCaseIndex]};
?>
            }
            <?
?>
        }
    }
    
    if schema.classes.count > 0 {
        <?// Types.
?>
        for uint32 classIndex = 0; classIndex < schema.classes.count; classIndex++ {
            SchemaClass class = schema.classes[classIndex];
            string className = schemaNamespace + "_" + class.name;
            if (class.superclass != NULL) {
                className += " : " + class.superclass.namespace + "_" + class.superclass.name;
            }
            <?#type ${className} {
?>
            for uint32 attributeIndex = 0; attributeIndex < class.attributes.count; attributeIndex++ {
                SchemaAttribute attribute = class.attributes[attributeIndex];
                string attributeType;
                if attribute.typeIsUIDReference || attribute.typeName == "UID" {
                    attributeType = "string";
                } else if attribute.typeIsClass {
                    attributeType = attribute.typeNamespace + "_" + attribute.typeName;
                } else if attribute.typeIsEnum {
                    attributeType = "uint32";
                } else {
                    attributeType = attribute.typeName;
                }
                bool isList = attribute.minOccurrences < 1 || attribute.maxOccurrences > 1;
                if (isList) {
                    string arrayQualifier = attribute.typeIsClass ? "Readonly" : "";
                    attributeType = arrayQualifier + "Array<" + attributeType + ">";
                }
                string attributeQualifier = isList || attribute.typeIsClass ? "readonly " : "";
                <?    ${attributeQualifier}${attributeType} ${attribute.name};?>
                if attribute.typeIsUIDReference {
                    <?  // References a UID on an object of type ${schemaNamespace}_${attribute.typeName}.?>
                } else if attribute.typeName == "UID" {
                    <?  // UID.?>
                }
                <?
?>
            }
            <?}

?>
        }
    }
}
