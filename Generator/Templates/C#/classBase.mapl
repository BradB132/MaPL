#import "../../Executable/MaPLGeneratorAPI.mapl"

Schema schema = (Schema)inParameters["schema"];
SchemaClass schemaClass = (SchemaClass)inParameters["class"];

bool useMaPLGeneratorSerialized = (bool)commandLineFlag("MaPLGeneratorSerialized");

string schemaNamespace = schema.namespace;
string className = schemaClass.name;

string outputDir = commandLineFlag("cSharpOutputDir");
outputToFile(outputDir + "/" + schemaNamespace + "/" + className + "_generated.cs");

<?// Generated by MaPLGenerator, based on the '${schemaNamespace}::${className}' schema.

?>
if useMaPLGeneratorSerialized {
<?using System.IO;

?>
}

<?namespace ${schemaNamespace};

?>

string superclassDeclaration;
string overrideSpecifier;
if schemaClass.superclass != NULL {
    superclassDeclaration = ": " + schemaClass.superclass.namespace + "." + schemaClass.superclass.name;
    if useMaPLGeneratorSerialized {
        superclassDeclaration += ", MaPLGeneratorSerialized";
    }
    overrideSpecifier = "override ";
} else {
    superclassDeclaration = useMaPLGeneratorSerialized ? ": MaPLGeneratorSerialized" : "";
    overrideSpecifier = "virtual ";
}

<?public class ${className}_generated${superclassDeclaration} {
?>

// The "omit" annotation causes the attribute to be ignored. Instead of checking for a non-zero
// number of attributes in `schemaClass.attributes`, determine if there are any non-omitted attributes.
bool hasAttributes = false;
for uint32 attrIndex = 0; attrIndex < schemaClass.attributes.count; attrIndex++ {
    SchemaAttribute attribute = schemaClass.attributes[attrIndex];
    if (!attribute.annotations.contains("omit")) {
        hasAttributes = true;
        break;
    }
}

if hasAttributes {
    for uint32 attrIndex = 0; attrIndex < schemaClass.attributes.count; attrIndex++ {
        SchemaAttribute attribute = schemaClass.attributes[attrIndex];
        if attribute.annotations.contains("omit") {
            continue;
        }
        bool requiresList = attribute.minOccurrences < 1 || attribute.maxOccurrences > 1;
        
        // Map the type of this attribute from its EaSL type to its Swift type.
        string dataType;
        if attribute.typeIsClass {
            dataType = attribute.typeNamespace + "." + attribute.typeName;
        } else if attribute.typeIsEnum {
            dataType = attribute.typeNamespace + "." + attribute.typeName;
        } else if attribute.isStringType {
            dataType = "string";
        } else if attribute.typeName == "int32" {
            dataType = "int";
        } else if attribute.typeName == "int64" {
            dataType = "long";
        } else if attribute.typeName == "uint32" {
            dataType = "uint";
        } else if attribute.typeName == "uint64" {
            dataType = "ulong";
        } else if attribute.typeName == "float32" {
            dataType = "float";
        } else if attribute.typeName == "float64" {
            dataType = "double";
        } else if attribute.typeName == "bool" {
            dataType = "bool";
        } else if attribute.typeName == "char" {
            dataType = "byte";
        } else {
            error("Unrecognized type: " + attribute.typeName);
        }
        if requiresList {
            dataType = "System.Collections.Generic.List<"+dataType+">";
        }
        
        <?    public ${dataType} ${attribute.name}?>
        
        if attribute.defaultValues.count == 0 {
            // All attributes must be initialized.
            if attribute.minOccurrences != 1 || attribute.maxOccurrences != 1 {
                <? = new ${dataType}();?>
            } else if attribute.typeIsClass {
                <?;?>
            } else if attribute.typeIsEnum {
                <? = (${dataType}.${attribute.typeName})0?>
            } else if attribute.isStringType {
                <? = "";?>
            } else if attribute.typeName == "bool" {
                <? = false;?>
            } else {
                <? = 0;?>
            }
        } else if attribute.defaultValues.count == 1 {
            if attribute.typeIsClass {
                <? = null;?>
            } else {
                <? = ?>
                if attribute.typeIsEnum {
                    <?${dataType}.?>
                }
                if attribute.typeName == "float32" {
                    <?${attribute.defaultValues[0]}f;?>
                } else {
                    <?${attribute.defaultValues[0]};?>
                }
            }
        } else {
            <? = new ${dataType} { ?>
            for uint32 defaultIndex = 0; defaultIndex < attribute.defaultValues.count; defaultIndex++ {
                string defaultValue;
                if attribute.typeIsEnum {
                    <?${dataType}.?>
                }
                if attribute.typeIsClass {
                    <?null?>
                } else if attribute.typeName == "float32" {
                    <?${attribute.defaultValues[defaultIndex]}f?>
                } else {
                    <?${attribute.defaultValues[defaultIndex]}?>
                }
                if defaultIndex < attribute.defaultValues.count-1 {
                    <?, ?>
                }
            }
            <? };?>
        }
        
        if attribute.typeIsUIDReference {
            <?  // Matches a UID on an object of type ${attribute.typeNamespace}.${attribute.typeName}.?>
        } else if attribute.typeName == "UID" {
            <?  // UID.?>
        }
        <?
?>
    }
}
<?
?>

if useMaPLGeneratorSerialized {
    if schemaClass.annotations.contains("root") {
<?    public static ${schemaNamespace}.${className} readFromFile(string filePath) {
        try {
            using (FileStream fileStream = File.OpenRead(filePath)) {
                using (BinaryReader reader = new BinaryReader(fileStream)) {
                    
                    // Ensure the endianness of this device matches that of the bytecode. `BinaryReader` assumes little endian.
                    // The first byte signals endianness of the remainder of the file (where 1 signals little endian).
                    bool flipEndian = reader.ReadByte() != 1;

                    System.Collections.Generic.List<byte> stringReader = new System.Collections.Generic.List<byte>(32);
                    ${schemaNamespace}.${className} createdObject = new ${schemaNamespace}.${className}();
                    if (!createdObject.initializeObject(reader, EndianReader.readUInt32(reader, flipEndian), flipEndian, stringReader)) {
                        return null;
                    }
                    return createdObject;
                }
            }
        } catch (System.Exception) {
            return null;
        }
    }

    public bool writeToFile(string filePath) {
        try {
            using (FileStream fileStream = File.OpenWrite(filePath)) {
                using (BinaryWriter writer = new BinaryWriter(fileStream)) {
                    // The `BinaryWriter` class always uses little endian. Add a "1" byte to signify this.
                    writer.Write((byte)(1));
                    writeObject(writer);
                    return true;
                }
            }
        } catch (System.Exception) {
            return false;
        }
    }

?>
    }
<?#region MaPLGeneratorSerialized
    public ${overrideSpecifier}bool initializeObject(BinaryReader reader, uint classBytecode, bool flipEndian, System.Collections.Generic.List<byte> stringReader) {
        if (classBytecode != MaPLGeneratorSerialized.BYTECODE_${schemaNamespace}_${className}_BEGIN) {
           return false;
        }
        MaPLGeneratorSerializedParseStatus result = MaPLGeneratorSerializedParseStatus.Success;
        while (result == MaPLGeneratorSerializedParseStatus.Success) {
            result = initializeAttribute(reader, EndianReader.readUInt32(reader, flipEndian), flipEndian, stringReader);
        }
        return result == MaPLGeneratorSerializedParseStatus.Completed;
    }

    public ${overrideSpecifier}MaPLGeneratorSerializedParseStatus initializeAttribute(BinaryReader reader, uint attributeBytecode, bool flipEndian, System.Collections.Generic.List<byte> stringReader) {
?>
    if hasAttributes {
<?        switch (attributeBytecode) {
            case MaPLGeneratorSerialized.BYTECODE_${schemaNamespace}_${className}_END:
                return MaPLGeneratorSerializedParseStatus.Completed;
?>
        for uint32 i = 0; i < schemaClass.attributes.count; i++ {
            SchemaAttribute attribute = schemaClass.attributes[i];
            if attribute.annotations.contains("omit") {
                continue;
            }
            string attributeName = attribute.name;
<?            case MaPLGeneratorSerialized.BYTECODE_${schemaNamespace}_${className}_${attributeName}: {
?>
            // Handle lists of values.
            bool requiresList = attribute.minOccurrences < 1 || attribute.maxOccurrences > 1;
            string indent = requiresList ? "    " : "";
            if requiresList {
                string listLength;
                if attribute.minOccurrences != attribute.maxOccurrences {  // Variable length.
<?                uint ${attributeName}Length = EndianReader.readUInt32(reader, flipEndian);
?>
                    listLength = attributeName + "Length";
                } else {  // Fixed length
                    listLength = (string)attribute.minOccurrences;
                }
<?                ${attributeName}.Clear();
                ${attributeName}.Capacity = (int)${listLength};
                for (int i = 0; i < ${listLength}; i++) {
?>
            }

            // Read ivar values.
            string typeName = attribute.typeName;
            if attribute.typeIsClass {
                string typeNamespace = attribute.typeNamespace;
                SchemaClass attributeClass = schemas[attribute.typeNamespace].classes[typeName];
                bool classIsOptional = attribute.defaultValues.count > 0;
<?${indent}                uint classBytecode = EndianReader.readUInt32(reader, flipEndian);
?>
                if attributeClass.descendantClasses.count > 0 {
<?${indent}                ${typeNamespace}.${typeName} createdObject;
${indent}                switch (classBytecode) {
${indent}                    case MaPLGeneratorSerialized.BYTECODE_${typeNamespace}_${typeName}_BEGIN:
${indent}                        createdObject = new ${typeNamespace}.${typeName}();
${indent}                        break;
?>
                    for uint32 descendantIndex = 0; descendantIndex < attributeClass.descendantClasses.count; descendantIndex++ {
                        SchemaClass descendant = attributeClass.descendantClasses[descendantIndex];
<?${indent}                    case MaPLGeneratorSerialized.BYTECODE_${descendant.namespace}_${descendant.name}_BEGIN:
${indent}                        createdObject = new ${descendant.namespace}.${descendant.name}();
${indent}                        break;
?>
                    }
<?${indent}                    default:
${indent}                        return MaPLGeneratorSerializedParseStatus.Error;
${indent}                }
?>
                } else {
<?${indent}                ${typeNamespace}.${typeName} createdObject = new ${typeNamespace}.${typeName}();
?>
                }
                
                if requiresList {
<?${indent}                ${attributeName}.Add(createdObject);
?>
                } else {
<?${indent}                ${attributeName} = createdObject;
?>
                }
<?${indent}                if (!createdObject.initializeObject(reader, classBytecode, flipEndian, stringReader)) {
${indent}                    return MaPLGeneratorSerializedParseStatus.Error;
${indent}                }
?>
            } else {
                string primitiveValue;
                if attribute.isStringType {
<?${indent}                stringReader.Clear();
${indent}                byte nextByte = reader.ReadByte();
${indent}                while (nextByte != 0) {
${indent}                    stringReader.Add(nextByte);
${indent}                    nextByte = reader.ReadByte();
${indent}                }
?>
                    primitiveValue = "System.Text.Encoding.UTF8.GetString(System.Runtime.InteropServices.CollectionsMarshal.AsSpan(stringReader))";
                } else if typeName == "int32" {
                    primitiveValue = "EndianReader.readInt32(reader, flipEndian)";
                } else if typeName == "uint32" {
                    primitiveValue = "EndianReader.readUInt32(reader, flipEndian)";
                } else if typeName == "int64" {
                    primitiveValue = "EndianReader.readInt64(reader, flipEndian)";
                } else if typeName == "uint64" {
                    primitiveValue = "EndianReader.readUInt64(reader, flipEndian)";
                } else if typeName == "float64" {
                    primitiveValue = "EndianReader.readDouble(reader, flipEndian)";
                } else if typeName == "float32" {
                    primitiveValue = "EndianReader.readFloat(reader, flipEndian)";
                } else if typeName == "bool" {
                    primitiveValue = "reader.ReadByte() != 0";
                } else if typeName == "char" {
                    primitiveValue = "reader.ReadByte()";
                } else if attribute.typeIsEnum {
                    primitiveValue = "(" + schemaNamespace + "." + typeName + ")EndianReader.readUInt32(reader, flipEndian)";
                }
                if requiresList {
<?${indent}                ${attributeName}.Add(${primitiveValue});
?>
                } else {
<?${indent}                ${attributeName} = ${primitiveValue};
?>
                }
            }

            if requiresList {
<?                }
?>
            }
<?                return MaPLGeneratorSerializedParseStatus.Success;
            }
?>
        }
<?            default:
                break;
        }
?>
    }
    if schemaClass.superclass != NULL {
<?        return base.initializeAttribute(reader, attributeBytecode, flipEndian, stringReader);
?>
    } else {
<?        return MaPLGeneratorSerializedParseStatus.Error;
?>
    }
<?    }

    public ${overrideSpecifier}void writeObject(BinaryWriter writer) {
        writer.Write(MaPLGeneratorSerialized.BYTECODE_${schemaNamespace}_${className}_BEGIN);
        writeAttributes(writer);
        writer.Write(MaPLGeneratorSerialized.BYTECODE_${schemaNamespace}_${className}_END);
    }

    public ${overrideSpecifier}void writeAttributes(BinaryWriter writer) {
?>
    for uint32 i = 0; i < schemaClass.attributes.count; i++ {
        SchemaAttribute attribute = schemaClass.attributes[i];
        if attribute.annotations.contains("omit") {
            continue;
        }
        string attributeName = attribute.name;
        
        // Check this value against the default value. Elide if it matches the default.
        // Lists with no default should be considered to have an empty default value.
        bool requiresList = attribute.minOccurrences < 1 || attribute.maxOccurrences > 1;
        bool hasDefaultValue = attribute.defaultValues.count > 0;
        string indent = requiresList || hasDefaultValue ? "    " : "";
        if requiresList || hasDefaultValue {
            string defaultConditional;
            if attribute.defaultValues.count == 1 {
                if attribute.typeIsClass {
                    defaultConditional = attributeName + " != null";
                } else {
                    string defaultValue = attribute.defaultValues[0];
                    if attribute.typeIsEnum {
                        defaultValue = attribute.typeNamespace + "." + attribute.typeName + "." + defaultValue;
                    } else if attribute.typeName == "float32" {
                        defaultValue = defaultValue + "f";
                    }
                    defaultConditional = attributeName + " != " + defaultValue;
                }
            } else {
                uint32 defaultListCount = hasDefaultValue ? attribute.defaultValues.count : 0;
                defaultConditional = attributeName + ".Count != " + (string)defaultListCount;
                for uint32 defaultIndex = 0; defaultIndex < attribute.defaultValues.count; defaultIndex++ {
                    string defaultValue = attribute.defaultValues[defaultIndex];
                    if attribute.typeIsEnum {
                        defaultValue = attribute.typeNamespace + "." + attribute.typeName + "." + defaultValue;
                    } else if attribute.typeName == "float32" {
                        defaultValue = defaultValue + "f";
                    }
                    defaultConditional += "\n            || " + attributeName + "[" + (string)defaultIndex + "] != " + defaultValue;
                }
            }
<?        if (${defaultConditional}) {
?>
        }
        
        // Specify which variable is being written.
<?${indent}        writer.Write(MaPLGeneratorSerialized.BYTECODE_${schemaNamespace}_${className}_${attributeName});
?>
        
        // Specify the length if this is a list of variable length.
        if attribute.minOccurrences != attribute.maxOccurrences {
            // Specify the length of this list.
<?${indent}        writer.Write((uint)${attributeName}.Count);
?>
        }
        
        // Specify the variable value.
        string attributeVar = requiresList ? attributeName + "[i]" : attributeName;
        string typeName = attribute.typeName;
        string typeNamespace = attribute.typeNamespace;
        if requiresList {
<?${indent}        for (int i = 0; i < ${attributeName}.Count; i++) {
?>
            indent += "    ";
        }
        
        if attribute.typeIsClass {
<?${indent}        ${attributeVar}.writeObject(writer);
?>
        } else {  // Primitives.
            if attribute.typeIsEnum {
<?${indent}        writer.Write((uint)${attributeVar});
?>
            } else if attribute.isStringType {
<?${indent}        int ${attributeName}ByteCount = System.Text.Encoding.UTF8.GetByteCount(${attributeVar});
${indent}        System.Span<byte> ${attributeName}Bytes = stackalloc byte[${attributeName}ByteCount];
${indent}        System.Text.Encoding.UTF8.GetBytes(${attributeVar}, ${attributeName}Bytes);
${indent}        for (int strIndex = 0; strIndex < ${attributeName}ByteCount; strIndex++) {
${indent}            writer.Write(${attributeName}Bytes[strIndex]);
${indent}        }
${indent}        writer.Write((byte)0);
?>
            } else if typeName == "bool" {
                if attribute.defaultValues.count == 1 {
                    // In the case that there's exactly 1 default value, we know this is a single bool, which is not the same as the default.
                    // This means there's only a single value that it can be, which should be hard coded.
                    if (bool)attribute.defaultValues[0] {
<?${indent}        writer.Write((byte)0);
?>
                    } else {
<?${indent}        writer.Write((byte)1);
?>
                    }
                } else {
<?${indent}        writer.Write((byte)(${attributeVar} ? 1 : 0));
?>
                }
            } else {
<?${indent}        writer.Write(${attributeVar});
?>
            }
        }
        
        if requiresList {
<?${indent}    }
?>
        }
        
        if requiresList || hasDefaultValue {
<?        }
?>
        }
    }
    if schemaClass.superclass != NULL {
<?        base.writeAttributes(writer);
?>
    } else if !hasAttributes {
<?        // No-op.
?>
    }
<?    }
?>
}
<?}
#endregion
?>
