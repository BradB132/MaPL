#import "../../Executable/MaPLGeneratorAPI.mapl"

string outputDir = commandLineFlag("cSharpOutputDir");
outputToFile(outputDir + "/MaPLGeneratorSerialized.cs");

<?// Generated by MaPLGenerator.

using System.IO;

public enum MaPLGeneratorSerializedParseStatus {
    Success,
    Error,
    Completed,
}

/**
 * Utility functions to fix endianness.
 */
public static class EndianReader {
    public static uint readUInt32(BinaryReader reader, bool flipEndian) {
        uint rawValue = reader.ReadUInt32();
        return flipEndian ? System.Buffers.Binary.BinaryPrimitives.ReverseEndianness(rawValue) : rawValue;
    }
    public static int readInt32(BinaryReader reader, bool flipEndian) {
        int rawValue = reader.ReadInt32();
        return flipEndian ? System.Buffers.Binary.BinaryPrimitives.ReverseEndianness(rawValue) : rawValue;
    }
    public static ulong readUInt64(BinaryReader reader, bool flipEndian) {
        ulong rawValue = reader.ReadUInt64();
        return flipEndian ? System.Buffers.Binary.BinaryPrimitives.ReverseEndianness(rawValue) : rawValue;
    }
    public static long readInt64(BinaryReader reader, bool flipEndian) {
        long rawValue = reader.ReadInt64();
        return flipEndian ? System.Buffers.Binary.BinaryPrimitives.ReverseEndianness(rawValue) : rawValue;
    }
    public static float readFloat(BinaryReader reader, bool flipEndian) {
        float rawValue = reader.ReadSingle();
        return flipEndian ? System.BitConverter.UInt32BitsToSingle(System.Buffers.Binary.BinaryPrimitives.ReverseEndianness(System.BitConverter.SingleToUInt32Bits(rawValue))) : rawValue;
    }
    public static double readDouble(BinaryReader reader, bool flipEndian) {
        double rawValue = reader.ReadDouble();
        return flipEndian ? System.BitConverter.UInt64BitsToDouble(System.Buffers.Binary.BinaryPrimitives.ReverseEndianness(System.BitConverter.DoubleToUInt64Bits(rawValue))) : rawValue;
    }
}

/**
 * Describes how generated objects are serialized / deserialized.
 */
public interface MaPLGeneratorSerialized {
    public bool initializeObject(BinaryReader reader, uint classBytecode, bool flipEndian, System.Collections.Generic.List<byte> stringReader);
    public MaPLGeneratorSerializedParseStatus initializeAttribute(BinaryReader reader, uint attributeBytecode, bool flipEndian, System.Collections.Generic.List<byte> stringReader);
    public void writeObject(BinaryWriter writer);
    public void writeAttributes(BinaryWriter writer);

?>

for uint32 schemaIndex = 0; schemaIndex < schemas.count; schemaIndex++ {
    Schema schema = schemas[schemaIndex];
    string schemaNamespace = schema.namespace;

    for uint32 classIndex = 0; classIndex < schema.classes.count; classIndex++ {
        SchemaClass schemaClass = schema.classes[classIndex];
        string classHashName = schemaClass.annotations.contains("originalName") ? schemaClass.annotations["originalName"] : schemaClass.name;
        uint32 beginClassHash = (uint32)hash("CLASS_BEGIN_" + schemaNamespace + "_" + classHashName);
        uint32 endClassHash = (uint32)hash("CLASS_END_" + schemaNamespace + "_" + classHashName);
<?    const uint BYTECODE_${schemaNamespace}_${schemaClass.name}_BEGIN = ${beginClassHash};
    const uint BYTECODE_${schemaNamespace}_${schemaClass.name}_END = ${endClassHash};
?>
        
        for uint32 attrIndex = 0; attrIndex < schemaClass.attributes.count; attrIndex++ {
            SchemaAttribute attribute = schemaClass.attributes[attrIndex];
            if attribute.annotations.contains("omit") {
                continue;
            }
            string attributeHashName = attribute.annotations.contains("originalName") ? attribute.annotations["originalName"] : attribute.name;
            uint32 attributeHash = (uint32)hash("ATTRIBUTE_" + schemaNamespace + "_" + classHashName + "_" + attributeHashName);
<?    const uint BYTECODE_${schemaNamespace}_${schemaClass.name}_${attribute.name} = ${attributeHash};
?>
        }
        if classIndex < schema.classes.count-1 {
<?
?>
        }
    }
}
<?}
?>
