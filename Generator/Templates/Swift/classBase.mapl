#import "../../Executable/MaPLGeneratorAPI.mapl"

Schema schema = (Schema)inParameters["schema"];
SchemaClass schemaClass = (SchemaClass)inParameters["class"];

bool useMaPLGeneratorSerialized = (bool)commandLineFlag("MaPLGeneratorSerialized");

string schemaNamespace = schema.namespace;
string className = schemaClass.name;

string outputDir = commandLineFlag("swiftOutputDir");
outputToFile(outputDir + "/" + schemaNamespace + "/" + className + "_generated.swift");

<?// Generated by MaPLGenerator, based on the '${schemaNamespace}::${className}' schema.

import Foundation

?>

string superclassDeclaration;
string overrideSpecifier;
if schemaClass.superclass != NULL {
    superclassDeclaration = ": " + schemaClass.superclass.namespace + "_" + schemaClass.superclass.name;
    overrideSpecifier = "override ";
} else {
    superclassDeclaration = useMaPLGeneratorSerialized ? ": MaPLGeneratorSerialized" : "";
    overrideSpecifier = "";
}

<?class ${schemaNamespace}_${className}_generated${superclassDeclaration} {
?>

// The "omit" annotation causes the attribute to be ignored. Instead of checking for a non-zero
// number of attributes in `schemaClass.attributes`, determine if there are any non-omitted attributes.
bool hasAttributes = false;
for uint32 attrIndex = 0; attrIndex < schemaClass.attributes.count; attrIndex++ {
    SchemaAttribute attribute = schemaClass.attributes[attrIndex];
    if (!attribute.annotations.contains("omit")) {
        hasAttributes = true;
        break;
    }
}

if hasAttributes {
    <?    // Properties.
?>
    for uint32 attrIndex = 0; attrIndex < schemaClass.attributes.count; attrIndex++ {
        SchemaAttribute attribute = schemaClass.attributes[attrIndex];
        if attribute.annotations.contains("omit") {
            continue;
        }
        
        bool requiresList = attribute.minOccurrences < 1 || attribute.maxOccurrences > 1;
        
        // Map the type of this attribute from its EaSL type to its Swift type.
        string dataType;
        if attribute.typeIsClass {
            dataType = attribute.typeNamespace + "_" + attribute.typeName;
            if attribute.defaultValues.count > 0 {
                dataType += "?";
            } else if !requiresList {
                dataType += "!";
            }
        } else if attribute.typeIsEnum {
            dataType = attribute.typeNamespace + "_" + attribute.typeName;
        } else if attribute.isStringType {
            dataType = "String";
        } else if attribute.typeName == "int32" {
            dataType = "Int32";
        } else if attribute.typeName == "int64" {
            dataType = "Int64";
        } else if attribute.typeName == "uint32" {
            dataType = "UInt32";
        } else if attribute.typeName == "uint64" {
            dataType = "UInt64";
        } else if attribute.typeName == "float32" {
            dataType = "Float32";
        } else if attribute.typeName == "float64" {
            dataType = "Float64";
        } else if attribute.typeName == "bool" {
            dataType = "Bool";
        } else if attribute.typeName == "char" {
            dataType = "UInt8";
        } else {
            error("Unrecognized type: " + attribute.typeName);
        }
        if requiresList {
            dataType = "[" + dataType + "]";
        }
        
        <?    var ${attribute.name}: ${dataType}?>
        
        if attribute.defaultValues.count == 0 {
            // All attributes must be initialized.
            if attribute.minOccurrences != 1 || attribute.maxOccurrences != 1 {
                <? = []?>
            } else if attribute.typeIsClass {
                // No-op.
            } else if attribute.typeIsEnum {
                <? = ${attribute.typeNamespace}_${attribute.typeName}(rawValue: 0)!?>
            } else if attribute.isStringType {
                <? = ""?>
            } else if attribute.typeName == "bool" {
                <? = false?>
            } else {
                <? = 0?>
            }
        } else if attribute.defaultValues.count == 1 {
            if attribute.typeIsClass {
                <? = nil?>
            } else {
                <? = ?>
                if attribute.typeIsEnum {
                    <?.?>
                }
                <?${attribute.defaultValues[0]}?>
            }
        } else {
            <? = [?>
            for uint32 defaultIndex = 0; defaultIndex < attribute.defaultValues.count; defaultIndex++ {
                string defaultValue;
                if attribute.typeIsEnum {
                    <?.?>
                }
                if attribute.typeIsClass {
                    <?nil?>
                } else {
                    <?${attribute.defaultValues[defaultIndex]}?>
                }
                if defaultIndex < attribute.defaultValues.count-1 {
                    <?, ?>
                }
            }
            <?]?>
        }
        
        if attribute.typeIsUIDReference {
            string referencedType = attribute.typeNamespace + "_" + attribute.typeName;
            <?  // Matches a UID on an object of type ${referencedType}.?>
        } else if attribute.typeName == "UID" {
            <?  // UID.?>
        }
        <?
?>
    }
}
<?
?>

if useMaPLGeneratorSerialized {
    if schemaClass.annotations.contains("root") {
<?    class func read(fromFileURL fileURL: URL) -> ${schemaNamespace}_${className}? {
        // Read the data from the file.
        guard let data = try? Data(contentsOf: fileURL) else { return nil }
        let dataArray: [UInt8] = data.withUnsafeBytes { Array($0) }
        guard dataArray.count >= 1 else { return nil }
        
        // Ensure the endianness of this device matches that of the bytecode.
        let machineIsLittleEndian = CFByteOrderGetCurrent() == CFByteOrder(CFByteOrderLittleEndian.rawValue)
        let bytecodeIsLittleEndian = dataArray[0] == 1
        guard machineIsLittleEndian == bytecodeIsLittleEndian else { return nil }
        
        // Init the object with the remaining data.
        let createdObject = ${schemaNamespace}_${className}()
        var dataIndex: Int = 1
        guard createdObject.initializeObject(withData: dataArray, dataIndex: &dataIndex), dataIndex == dataArray.count else { return nil }
        return createdObject
    }

    func write(toFileURL fileURL: URL) -> Bool {
        var data = Data()
        data.append(CFByteOrderGetCurrent() == CFByteOrder(CFByteOrderLittleEndian.rawValue) ? 1 : 0)
        writeObject(toData: &data)
        do {
            try data.write(to: fileURL)
            return true
        } catch {
            return false
        }
    }

?>
    }
<?    // MARK: MaPLGeneratorSerialized.
    ${overrideSpecifier}func initializeObject(withData data: [UInt8], dataIndex: inout Int) -> Bool {
        if dataIndex+4 > data.count ||
           (UInt32(data[dataIndex]) | UInt32(data[dataIndex+1]) << 8 | UInt32(data[dataIndex+2]) << 16 | UInt32(data[dataIndex+3]) << 24) != BYTECODE_${schemaNamespace}_${className}_BEGIN {
           return false
        }
        dataIndex += 4
        var result: MaPLGeneratorSerializedParseStatus = .success
        while result == .success {
            result = initializeAttribute(withData: data, dataIndex: &dataIndex)
        }
        return result == .completed
    }

    ${overrideSpecifier}func initializeAttribute(withData data: [UInt8], dataIndex: inout Int) -> MaPLGeneratorSerializedParseStatus {
?>
    if hasAttributes {
<?        if (dataIndex+4 > data.count) {
            return .error
        }
        let nextAttributeName = UInt32(data[dataIndex]) | UInt32(data[dataIndex+1]) << 8 | UInt32(data[dataIndex+2]) << 16 | UInt32(data[dataIndex+3]) << 24
        dataIndex += 4
        switch (nextAttributeName) {
            case BYTECODE_${schemaNamespace}_${className}_END:
                return .completed
?>
        for uint32 i = 0; i < schemaClass.attributes.count; i++ {
            SchemaAttribute attribute = schemaClass.attributes[i];
            if attribute.annotations.contains("omit") {
                continue;
            }
        
            string attributeName = attribute.name;
<?            case BYTECODE_${schemaNamespace}_${className}_${attributeName}:
?>
            // Handle lists of values.
            bool requiresList = attribute.minOccurrences < 1 || attribute.maxOccurrences > 1;
            string indent = requiresList ? "    " : "";
            if requiresList {
                string listLength;
                if attribute.minOccurrences != attribute.maxOccurrences {  // Variable length.
<?                if dataIndex+4 > data.count {
                    return .error
                }
                let ${attributeName}Length: UInt32 = UInt32(data[dataIndex]) | UInt32(data[dataIndex+1]) << 8 | UInt32(data[dataIndex+2]) << 16 | UInt32(data[dataIndex+3]) << 24
                dataIndex += 4
?>
                    listLength = attributeName + "Length";
                } else {  // Fixed length
                    listLength = (string)attribute.minOccurrences;
                }
<?                ${attributeName}.removeAll()
                ${attributeName}.reserveCapacity(Int(${listLength}))
                for _ in 0..<${listLength} {
?>
            }

            // Read ivar values.
            string typeName = attribute.typeName;
            if attribute.typeIsClass {
                string typeNamespace = attribute.typeNamespace;
                SchemaClass attributeClass = schemas[attribute.typeNamespace].classes[typeName];
                bool classIsOptional = attribute.defaultValues.count > 0;
                if attributeClass.descendantClasses.count > 0 {
<?${indent}                if dataIndex+4 > data.count {
${indent}                    return .error
${indent}                }
${indent}                let createdObject: ${typeNamespace}_${typeName}!
${indent}                switch (UInt32(data[dataIndex]) | UInt32(data[dataIndex+1]) << 8 | UInt32(data[dataIndex+2]) << 16 | UInt32(data[dataIndex+3]) << 24) {
${indent}                    case BYTECODE_${typeNamespace}_${typeName}_BEGIN:
${indent}                        createdObject = ${typeNamespace}_${typeName}()
?>
                    for uint32 descendantIndex = 0; descendantIndex < attributeClass.descendantClasses.count; descendantIndex++ {
                        SchemaClass descendant = attributeClass.descendantClasses[descendantIndex];
<?${indent}                    case BYTECODE_${descendant.namespace}_${descendant.name}_BEGIN:
${indent}                        createdObject = ${descendant.namespace}_${descendant.name}()
?>
                    }
<?${indent}                    default:
${indent}                        return .error
${indent}                }
?>
                } else {
<?${indent}                let createdObject = ${typeNamespace}_${typeName}()
?>
                }
                
                if requiresList {
<?${indent}                ${attributeName}.append(createdObject)
?>
                } else {
<?${indent}                ${attributeName} = createdObject
?>
                }
<?${indent}                if !createdObject.initializeObject(withData: data, dataIndex: &dataIndex) {
${indent}                    return .error
${indent}                }
?>
            } else if attribute.isStringType {
<?${indent}                var stringEndIndex = dataIndex
${indent}                while stringEndIndex < data.count {
${indent}                    if data[stringEndIndex] == 0 {
${indent}                        break
${indent}                    }
${indent}                    stringEndIndex += 1
${indent}                }
?>
                if requiresList {
<?${indent}                ${attributeName}.append(String(decoding: data[dataIndex..<stringEndIndex], as: UTF8.self))
?>
                } else {
<?${indent}                ${attributeName} = String(decoding: data[dataIndex..<stringEndIndex], as: UTF8.self)
?>
                }
<?${indent}                dataIndex += (stringEndIndex - dataIndex) + 1
?>
            } else {
                uint32 primitiveSize;
                if typeName == "int64" || typeName == "float64" || typeName == "uint64" {
                    primitiveSize = 8;
                } else if typeName == "bool" || typeName == "char" {
                    primitiveSize = 1;
                } else {
                    primitiveSize = 4;
                }
                
<?${indent}                if (dataIndex+${primitiveSize} > data.count) {
${indent}                    return .error
${indent}                }
?>

                string primitiveValue;
                if typeName == "int32" {
<?${indent}                let bitPattern: UInt32 = UInt32(data[dataIndex]) | UInt32(data[dataIndex+1]) << 8 | UInt32(data[dataIndex+2]) << 16 | UInt32(data[dataIndex+3]) << 24
?>
                    primitiveValue = "Int32(bitPattern: bitPattern)";
                } else if typeName == "uint32" {
                    primitiveValue = "UInt32(data[dataIndex]) | UInt32(data[dataIndex+1]) << 8 | UInt32(data[dataIndex+2]) << 16 | UInt32(data[dataIndex+3]) << 24";
                } else if typeName == "int64" || typeName == "uint64" || typeName == "float64" {
<?${indent}                // Split `bitPattern` declaration into multiple statements, otherwise the compiler will complain that it takes too long to typecheck.
${indent}                var bitPattern: UInt64 = UInt64(data[dataIndex])
${indent}                bitPattern |= UInt64(data[dataIndex+1]) << 8
${indent}                bitPattern |= UInt64(data[dataIndex+2]) << 16
${indent}                bitPattern |= UInt64(data[dataIndex+3]) << 24
${indent}                bitPattern |= UInt64(data[dataIndex+4]) << 32
${indent}                bitPattern |= UInt64(data[dataIndex+5]) << 40
${indent}                bitPattern |= UInt64(data[dataIndex+6]) << 48
${indent}                bitPattern |= UInt64(data[dataIndex+7]) << 56
?>
                    if typeName == "int64" {
                        primitiveValue = "Int64(bitPattern: bitPattern)";
                    } else if typeName == "uint64" {
                        primitiveValue = "bitPattern";
                    } else { // float64.
                        primitiveValue = "Float64(bitPattern: bitPattern)";
                    }
                } else if typeName == "float32" {
<?${indent}                let bitPattern: UInt32 = UInt32(data[dataIndex]) | UInt32(data[dataIndex+1]) << 8 | UInt32(data[dataIndex+2]) << 16 | UInt32(data[dataIndex+3]) << 24
?>
                    primitiveValue = "Float32(bitPattern: bitPattern)";
                } else if typeName == "bool" {
                    primitiveValue = "data[dataIndex] != 0";
                } else if typeName == "char" {
                    primitiveValue = "data[dataIndex]";
                } else if attribute.typeIsEnum {
<?${indent}                let rawValue: UInt32 = UInt32(data[dataIndex]) | UInt32(data[dataIndex+1]) << 8 | UInt32(data[dataIndex+2]) << 16 | UInt32(data[dataIndex+3]) << 24
${indent}                guard let enumValue = ${schemaNamespace}_${typeName}(rawValue: rawValue) else { return .error }
?>
                    primitiveValue = "enumValue";
                }
                if requiresList {
<?${indent}                ${attributeName}.append(${primitiveValue})
?>
                } else {
<?${indent}                ${attributeName} = ${primitiveValue}
?>
                }
<?${indent}                dataIndex += ${primitiveSize}
?>
            }

            if requiresList {
<?                }
?>
            }
<?                return .success
?>
        }
<?            default:
?>
        if schemaClass.superclass != NULL {
<?                dataIndex -= 4
?>
        }
<?                break
        }
?>
    }
    if schemaClass.superclass != NULL {
<?        return super.initializeAttribute(withData: data, dataIndex: &dataIndex)
?>
    } else {
<?        return .error
?>
    }
<?    }

    ${overrideSpecifier}func writeObject(toData data: inout Data) {
        var bytecodeSignifier: UInt32 = BYTECODE_${schemaNamespace}_${className}_BEGIN
        data.append(UInt8(truncatingIfNeeded:bytecodeSignifier))
        data.append(UInt8(truncatingIfNeeded:bytecodeSignifier >> 8))
        data.append(UInt8(truncatingIfNeeded:bytecodeSignifier >> 16))
        data.append(UInt8(bytecodeSignifier >> 24))
        writeAttributes(toData: &data)
        bytecodeSignifier = BYTECODE_${schemaNamespace}_${className}_END
        data.append(UInt8(truncatingIfNeeded:bytecodeSignifier))
        data.append(UInt8(truncatingIfNeeded:bytecodeSignifier >> 8))
        data.append(UInt8(truncatingIfNeeded:bytecodeSignifier >> 16))
        data.append(UInt8(bytecodeSignifier >> 24))
    }

    ${overrideSpecifier}func writeAttributes(toData data: inout Data) {
?>
    if hasAttributes {
<?        var bytecodeSignifier: UInt32
?>
    }
    for uint32 i = 0; i < schemaClass.attributes.count; i++ {
        SchemaAttribute attribute = schemaClass.attributes[i];
        if attribute.annotations.contains("omit") {
            continue;
        }
        string attributeName = attribute.name;
        
        // Check this value against the default value. Elide if it matches the default.
        // Lists with no default should be considered to have an empty default value.
        bool requiresList = attribute.minOccurrences < 1 || attribute.maxOccurrences > 1;
        bool hasDefaultValue = attribute.defaultValues.count > 0;
        string indent = requiresList || hasDefaultValue ? "    " : "";
        if requiresList || hasDefaultValue {
            string defaultConditional;
            if attribute.defaultValues.count == 1 {
                if attribute.typeIsClass {
                    defaultConditional = "let " + attributeName + " = " + attributeName;
                } else {
                    string defaultValue = attribute.defaultValues[0];
                    if attribute.typeIsEnum {
                        defaultValue = "." + defaultValue;
                    }
                    defaultConditional = attributeName + " != " + defaultValue;
                }
            } else {
                uint32 defaultListCount = hasDefaultValue ? attribute.defaultValues.count : 0;
                defaultConditional = attributeName + ".count != " + (string)defaultListCount;
                for uint32 defaultIndex = 0; defaultIndex < attribute.defaultValues.count; defaultIndex++ {
                    string defaultValue = attribute.defaultValues[defaultIndex];
                    if attribute.typeIsEnum {
                        defaultValue = "." + defaultValue;
                    }
                    defaultConditional += "\n            || " + attributeName + "[" + (string)defaultIndex + "] != " + defaultValue;
                }
            }
<?        if ${defaultConditional} {
?>
        }
        
        // Specify which variable is being written.
<?${indent}        bytecodeSignifier = BYTECODE_${schemaNamespace}_${className}_${attributeName}
${indent}        data.append(UInt8(truncatingIfNeeded:bytecodeSignifier))
${indent}        data.append(UInt8(truncatingIfNeeded:bytecodeSignifier >> 8))
${indent}        data.append(UInt8(truncatingIfNeeded:bytecodeSignifier >> 16))
${indent}        data.append(UInt8(bytecodeSignifier >> 24))
?>
        
        // Specify the length if this is a list of variable length.
        if attribute.minOccurrences != attribute.maxOccurrences {
            // Specify the length of this list.
<?${indent}        bytecodeSignifier = UInt32(${attributeName}.count)
${indent}        data.append(UInt8(truncatingIfNeeded:bytecodeSignifier))
${indent}        data.append(UInt8(truncatingIfNeeded:bytecodeSignifier >> 8))
${indent}        data.append(UInt8(truncatingIfNeeded:bytecodeSignifier >> 16))
${indent}        data.append(UInt8(bytecodeSignifier >> 24))
?>
        }
        
        // Specify the variable value.
        string attributeVar = requiresList ? attributeName + "Value" : attributeName;
        string typeName = attribute.typeName;
        string typeNamespace = attribute.typeNamespace;
        if requiresList {
<?${indent}        for ${attributeVar} in ${attributeName} {
?>
            indent += "    ";
        }
        
        if attribute.typeIsClass {
<?${indent}        ${attributeVar}.writeObject(toData: &data)
?>
        } else {  // Primitives.
            if typeName == "uint32" {
<?${indent}        data.append(UInt8(truncatingIfNeeded:${attributeVar}))
${indent}        data.append(UInt8(truncatingIfNeeded:${attributeVar} >> 8))
${indent}        data.append(UInt8(truncatingIfNeeded:${attributeVar} >> 16))
${indent}        data.append(UInt8(${attributeVar} >> 24))
?>
            } else if attribute.typeIsEnum ||  // Enums are UInt32.
               typeName == "int32" ||
               typeName == "float32" {
                if attribute.typeIsEnum {
<?${indent}        bytecodeSignifier = ${attributeVar}.rawValue
?>
                } else if typeName == "int32" {
<?${indent}        bytecodeSignifier = UInt32(bitPattern: ${attributeVar})
?>
                } else {  // float32.
<?${indent}        bytecodeSignifier = ${attributeVar}.bitPattern
?>
                }
               
<?${indent}        data.append(UInt8(truncatingIfNeeded:bytecodeSignifier))
${indent}        data.append(UInt8(truncatingIfNeeded:(bytecodeSignifier >> 8)))
${indent}        data.append(UInt8(truncatingIfNeeded:(bytecodeSignifier >> 16)))
${indent}        data.append(UInt8(bytecodeSignifier >> 24))
?>
            } else if typeName == "uint64" {
<?${indent}        data.append(UInt8(truncatingIfNeeded:${attributeVar}))
${indent}        data.append(UInt8(truncatingIfNeeded:${attributeVar} >> 8))
${indent}        data.append(UInt8(truncatingIfNeeded:${attributeVar} >> 16))
${indent}        data.append(UInt8(truncatingIfNeeded:${attributeVar} >> 24))
${indent}        data.append(UInt8(truncatingIfNeeded:${attributeVar} >> 32))
${indent}        data.append(UInt8(truncatingIfNeeded:${attributeVar} >> 40))
${indent}        data.append(UInt8(truncatingIfNeeded:${attributeVar} >> 48))
${indent}        data.append(UInt8(${attributeVar} >> 56))
?>
            } else if typeName == "int64" ||
                      typeName == "float64" {
                if typeName == "int64" {
<?${indent}        let bitPattern = UInt64(bitPattern: ${attributeVar})
?>
                } else {  // float64.
<?${indent}        let bitPattern: UInt64 = ${attributeVar}.bitPattern
?>
                }
<?${indent}        data.append(UInt8(truncatingIfNeeded:bitPattern))
${indent}        data.append(UInt8(truncatingIfNeeded:bitPattern >> 8))
${indent}        data.append(UInt8(truncatingIfNeeded:bitPattern >> 16))
${indent}        data.append(UInt8(truncatingIfNeeded:bitPattern >> 24))
${indent}        data.append(UInt8(truncatingIfNeeded:bitPattern >> 32))
${indent}        data.append(UInt8(truncatingIfNeeded:bitPattern >> 40))
${indent}        data.append(UInt8(truncatingIfNeeded:bitPattern >> 48))
${indent}        data.append(UInt8(bitPattern >> 56))
?>
            } else if typeName == "bool" {
                if attribute.defaultValues.count == 1 {
                    // In the case that there's exactly 1 default value, we know this is a single bool, which is not the same as the default.
                    // This means there's only a single value that it can be, which should be hard coded.
                    if (bool)attribute.defaultValues[0] {
<?${indent}        data.append(0)
?>
                    } else {
<?${indent}        data.append(1)
?>
                    }
                } else {
<?${indent}        data.append(${attributeVar} ? 1 : 0)
?>
                }
            } else if typeName == "char" {
<?${indent}        data.append(${attributeVar})
?>
            } else if attribute.isStringType {
<?${indent}        for char in ${attributeVar}.utf8 {
${indent}            data.append(char)
${indent}        }
${indent}        data.append(0)
?>
            } else {
                error("Unrecognized type for attribute "+schemaNamespace+"::"+className+"::"+attributeName);
            }
        }
        
        if requiresList {
<?${indent}    }
?>
        }
        
        if requiresList || hasDefaultValue {
<?        }
?>
        }
    }
    if schemaClass.superclass != NULL {
<?        super.writeAttributes(toData: &data)
?>
    } else if !hasAttributes {
<?        // No-op.
?>
    }
<?    }
?>
}
<?}
?>
