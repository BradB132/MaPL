#import "../../Executable/MaPLGeneratorAPI.mapl"

Schema schema = (Schema)inParameters["schema"];
SchemaClass schemaClass = (SchemaClass)inParameters["class"];

bool useMaPLGeneratorSerialized = (bool)commandLineFlag("MaPLGeneratorSerialized");

string schemaNamespace = schema.namespace;
string className = schemaClass.name;

string outputDir = commandLineFlag("swiftOutputDir");
outputToFile(outputDir + "/" + schemaNamespace + "/" + className + "_generated.swift");

<?// Generated by MaPLGenerator, based on the '${schemaNamespace}::${className}' schema.

import Foundation

?>

string superclassDeclaration;
string overrideSpecifier;
if schemaClass.superclass != NULL {
    superclassDeclaration = ": " + schemaClass.superclass.namespace + "_" + schemaClass.superclass.name;
    overrideSpecifier = "override ";
} else {
    superclassDeclaration = useMaPLGeneratorSerialized ? ": MaPLGeneratorSerialized" : "";
    overrideSpecifier = "";
}

<?class ${schemaNamespace}_${className}_generated${superclassDeclaration} {
?>

if schemaClass.attributes.count > 0 {
    <?    // Properties.
?>
    for uint32 attrIndex = 0; attrIndex < schemaClass.attributes.count; attrIndex++ {
        SchemaAttribute attribute = schemaClass.attributes[attrIndex];
        bool requiresList = attribute.minOccurrences < 1 || attribute.maxOccurrences > 1;
        
        // Map the type of this attribute from its EaSL type to its Swift type.
        string dataType;
        if attribute.typeIsClass {
            dataType = attribute.typeNamespace + "_" + attribute.typeName;
            if attribute.defaultValues.count > 0 {
                dataType += "?";
            } else if !requiresList {
                dataType += "!";
            }
        } else if attribute.typeIsEnum {
            dataType = attribute.typeNamespace + "_" + attribute.typeName;
        } else if attribute.typeIsUIDReference || attribute.typeName == "string" || attribute.typeName == "UID" {
            dataType = "String";
        } else if attribute.typeName == "int32" {
            dataType = "Int32";
        } else if attribute.typeName == "int64" {
            dataType = "Int64";
        } else if attribute.typeName == "uint32" {
            dataType = "UInt32";
        } else if attribute.typeName == "uint64" {
            dataType = "UInt64";
        } else if attribute.typeName == "float32" {
            dataType = "Float32";
        } else if attribute.typeName == "float64" {
            dataType = "Float64";
        } else if attribute.typeName == "bool" {
            dataType = "Bool";
        } else if attribute.typeName == "char" {
            dataType = "UInt8";
        } else {
            error("Unrecognized type: " + attribute.typeName);
        }
        if requiresList {
            dataType = "[" + dataType + "]";
        }
        
        <?    var ${attribute.name}: ${dataType}?>
        if attribute.typeIsUIDReference {
            string referencedType = attribute.typeNamespace + "_" + attribute.typeName;
            <?  // Matches a UID on an object of type ${referencedType}.?>
        } else if attribute.typeName == "UID" {
            <?  // UID.?>
        }
        <?
?>
    }
}
<?
    ${overrideSpecifier}init() {
?>

for uint32 attrIndex = 0; attrIndex < schemaClass.attributes.count; attrIndex++ {
    SchemaAttribute attribute = schemaClass.attributes[attrIndex];
    string attributeValue;
    if attribute.defaultValues.count == 0 {
        // All attributes must be initialized.
        if attribute.minOccurrences != 1 || attribute.maxOccurrences != 1 {
            attributeValue = "[]";
        } else if attribute.typeIsClass {
<?        // '${attribute.name}' intentionally not yet initialized.
?>
            continue;
        } else if attribute.typeIsEnum {
            attributeValue = attribute.typeNamespace + "_" + attribute.typeName + "(rawValue: 0)!";
        } else if attribute.typeIsUIDReference ||
                  attribute.typeName == "string" ||
                  attribute.typeName == "UID" {
            attributeValue = "\"\"";
        } else if attribute.typeName == "bool" {
            attributeValue = "false";
        } else {
            attributeValue = "0";
        }
    } else if attribute.defaultValues.count == 1 {
        if attribute.typeIsClass {
            attributeValue = "nil";  // NULL is only default value for classes.
        } else {
            attributeValue = attribute.defaultValues[0];
            if attribute.typeIsEnum {
                attributeValue = "." + attributeValue;
            }
        }
    } else {
        attributeValue = "[";
        for uint32 defaultIndex = 0; defaultIndex < attribute.defaultValues.count; defaultIndex++ {
            string defaultValue;
            if attribute.typeIsClass {
                defaultValue = "nil";  // NULL is only default value for classes.
            } else {
                defaultValue = attribute.defaultValues[defaultIndex];
            }
            if attribute.typeIsEnum {
                attributeValue += "." + defaultValue;
            } else {
                attributeValue += defaultValue;
            }
            if defaultIndex < attribute.defaultValues.count-1 {
                attributeValue +=  ", ";
            }
        }
        attributeValue += "]";
    }
<?        ${attribute.name} = ${attributeValue}
?>
}
<?    }

?>

if useMaPLGeneratorSerialized {
    if schemaClass.annotations.contains("root") {
<?    class func read(fromFileURL fileURL: URL) -> ${schemaNamespace}_${className}? {
        // Read the data from the file.
        guard let data = try? Data(contentsOf: fileURL) else { return nil }
        let dataArray: [UInt8] = data.withUnsafeBytes { Array($0) }
        guard dataArray.count >= 1 else { return nil }
        
        // Ensure the endianness of this device matches that of the bytecode.
        let machineIsLittleEndian = CFByteOrderGetCurrent() == CFByteOrder(CFByteOrderLittleEndian.rawValue)
        let scriptIsLittleEndian = dataArray[0] == 1
        guard machineIsLittleEndian == scriptIsLittleEndian else { return nil }
        
        // Init the object with the remaining data.
        let createdObject = ${schemaNamespace}_${className}()
        var dataIndex: Int = 1
        guard createdObject.initializeObject(withData: dataArray, dataIndex: &dataIndex), dataIndex == dataArray.count else { return nil }
        return createdObject
    }

    func write(toFileURL fileURL: URL) -> Bool {
        var data = Data()
        data.append(CFByteOrderGetCurrent() == CFByteOrder(CFByteOrderLittleEndian.rawValue) ? 1 : 0)
        writeObject(toData: &data)
        do {
            try data.write(to: fileURL)
            return true
        } catch {
            return false
        }
    }

?>
    }
<?    // MARK: MaPLGeneratorSerialized.
    ${overrideSpecifier}func initializeObject(withData data: [UInt8], dataIndex: inout Int) -> Bool {
        if dataIndex+4 > data.count ||
           (UInt32(data[dataIndex]) | UInt32(data[dataIndex+1]) << 8 | UInt32(data[dataIndex+2]) << 16 | UInt32(data[dataIndex+3]) << 24) != BYTECODE_${schemaNamespace}_${className} {
           return false
        }
        dataIndex += 4
        while initializeAttribute(withData: data, dataIndex: &dataIndex) {}
        return true
    }

    ${overrideSpecifier}func initializeAttribute(withData data: [UInt8], dataIndex: inout Int) -> Bool {
?>
    if schemaClass.attributes.count > 0 {
<?        if (dataIndex+4 > data.count) {
            return false
        }
        let nextAttributeName = UInt32(data[dataIndex]) | UInt32(data[dataIndex+1]) << 8 | UInt32(data[dataIndex+2]) << 16 | UInt32(data[dataIndex+3]) << 24
        dataIndex += 4
        switch (nextAttributeName) {
?>
        for uint32 i = 0; i < schemaClass.attributes.count; i++ {
            SchemaAttribute attribute = schemaClass.attributes[i];
            string attributeName = attribute.name;
<?            case BYTECODE_${schemaNamespace}_${className}_${attributeName}:
?>
            // Handle lists of values.
            bool requiresList = attribute.minOccurrences < 1 || attribute.maxOccurrences > 1;
            string indent = requiresList ? "    " : "";
            if requiresList {
                string listLength;
                if attribute.minOccurrences != attribute.maxOccurrences {  // Variable length.
<?                if dataIndex+4 > data.count {
                    return false
                }
                let ${attributeName}Length: UInt32 = UInt32(data[dataIndex]) | UInt32(data[dataIndex+1]) << 8 | UInt32(data[dataIndex+2]) << 16 | UInt32(data[dataIndex+3]) << 24
                dataIndex += 4
?>
                    listLength = attributeName + "Length";
                } else {  // Fixed length
                    listLength = (string)attribute.minOccurrences;
                }
<?                ${attributeName}.removeAll()
                ${attributeName}.reserveCapacity(Int(${listLength}))
                for _ in 0..<${listLength} {
?>
            }

            // Read ivar values.
            string typeName = attribute.typeName;
            if attribute.typeIsClass {
                string typeNamespace = attribute.typeNamespace;
                SchemaClass attributeClass = schemas[attribute.typeNamespace].classes[typeName];
                bool classIsOptional = attribute.defaultValues.count > 0;
                if attributeClass.descendantClasses.count > 0 {
<?${indent}                if dataIndex+4 > data.count {
${indent}                    return false
${indent}                }
${indent}                let createdObject: ${typeNamespace}_${typeName}!
${indent}                switch (UInt32(data[dataIndex]) | UInt32(data[dataIndex+1]) << 8 | UInt32(data[dataIndex+2]) << 16 | UInt32(data[dataIndex+3]) << 24) {
${indent}                    case BYTECODE_${typeNamespace}_${typeName}:
${indent}                        createdObject = ${typeNamespace}_${typeName}()
?>
                    for uint32 descendantIndex = 0; descendantIndex < attributeClass.descendantClasses.count; descendantIndex++ {
                        SchemaClass descendant = attributeClass.descendantClasses[descendantIndex];
<?${indent}                    case BYTECODE_${descendant.namespace}_${descendant.name}:
${indent}                        createdObject = ${descendant.namespace}_${descendant.name}()
?>
                    }
<?${indent}                    default:
${indent}                        return false
${indent}                }
?>
                } else {
<?${indent}                let createdObject = ${typeNamespace}_${typeName}()
?>
                }
                
                if requiresList {
<?${indent}                ${attributeName}.append(createdObject)
?>
                } else {
<?${indent}                ${attributeName} = createdObject
?>
                }
<?${indent}                if !createdObject.initializeObject(withData: data, dataIndex: &dataIndex) {
${indent}                    return false
${indent}                }
?>
            } else if attribute.typeIsUIDReference ||
                      typeName == "string" ||
                      typeName == "UID" {
<?${indent}                var stringEndIndex = dataIndex
${indent}                while stringEndIndex < data.count {
${indent}                    if data[stringEndIndex] == 0 {
${indent}                        break
${indent}                    }
${indent}                    stringEndIndex += 1
${indent}                }
?>
                if requiresList {
<?${indent}                ${attributeName}.append(String(decoding: data[dataIndex..<stringEndIndex], as: UTF8.self))
?>
                } else {
<?${indent}                ${attributeName} = String(decoding: data[dataIndex..<stringEndIndex], as: UTF8.self)
?>
                }
<?${indent}                dataIndex += (stringEndIndex - dataIndex) + 1
?>
            } else {
                uint32 primitiveSize;
                if typeName == "int64" || typeName == "float64" || typeName == "uint64" {
                    primitiveSize = 8;
                } else if typeName == "bool" || typeName == "char" {
                    primitiveSize = 1;
                } else {
                    primitiveSize = 4;
                }
                
<?${indent}                if (dataIndex+${primitiveSize} > data.count) {
${indent}                    return false
${indent}                }
?>

                string primitiveValue;
                if typeName == "int32" {
<?${indent}                let bitPattern: UInt32 = UInt32(data[dataIndex]) | UInt32(data[dataIndex+1]) << 8 | UInt32(data[dataIndex+2]) << 16 | UInt32(data[dataIndex+3]) << 24
?>
                    primitiveValue = "Int32(bitPattern: bitPattern)";
                } else if typeName == "uint32" {
                    primitiveValue = "UInt32(data[dataIndex]) | UInt32(data[dataIndex+1]) << 8 | UInt32(data[dataIndex+2]) << 16 | UInt32(data[dataIndex+3]) << 24";
                } else if typeName == "int64" || typeName == "uint64" || typeName == "float64" {
<?${indent}                // Split `bitPattern` declaration into multiple statements, otherwise the compiler will complain that it takes too long to typecheck.
${indent}                var bitPattern: UInt64 = UInt64(data[dataIndex])
${indent}                bitPattern |= UInt64(data[dataIndex+1]) << 8
${indent}                bitPattern |= UInt64(data[dataIndex+2]) << 16
${indent}                bitPattern |= UInt64(data[dataIndex+3]) << 24
${indent}                bitPattern |= UInt64(data[dataIndex+4]) << 32
${indent}                bitPattern |= UInt64(data[dataIndex+5]) << 40
${indent}                bitPattern |= UInt64(data[dataIndex+6]) << 48
${indent}                bitPattern |= UInt64(data[dataIndex+7]) << 56
?>
                    if typeName == "int64" {
                        primitiveValue = "Int64(bitPattern: bitPattern)";
                    } else if typeName == "uint64" {
                        primitiveValue = "bitPattern";
                    } else { // float64.
                        primitiveValue = "Float64(bitPattern: bitPattern)";
                    }
                } else if typeName == "float32" {
<?${indent}                let bitPattern: UInt32 = UInt32(data[dataIndex]) | UInt32(data[dataIndex+1]) << 8 | UInt32(data[dataIndex+2]) << 16 | UInt32(data[dataIndex+3]) << 24
?>
                    primitiveValue = "Float32(bitPattern: bitPattern)";
                } else if typeName == "bool" {
                    primitiveValue = "data[dataIndex] != 0";
                } else if typeName == "char" {
                    primitiveValue = "data[dataIndex]";
                } else if attribute.typeIsEnum {
<?${indent}                let rawValue: UInt32 = UInt32(data[dataIndex]) | UInt32(data[dataIndex+1]) << 8 | UInt32(data[dataIndex+2]) << 16 | UInt32(data[dataIndex+3]) << 24
${indent}                guard let enumValue = ${schemaNamespace}_${typeName}(rawValue: rawValue) else { return false }
?>
                    primitiveValue = "enumValue";
                }
                if requiresList {
<?${indent}                ${attributeName}.append(${primitiveValue})
?>
                } else {
<?${indent}                ${attributeName} = ${primitiveValue}
?>
                }
<?${indent}                dataIndex += ${primitiveSize}
?>
            }

            if requiresList {
<?                }
?>
            }
<?                return true
?>
        }
<?            default:
                dataIndex -= 4
                break
        }
?>
    }
    if schemaClass.superclass != NULL {
<?        return super.initializeAttribute(withData: data, dataIndex: &dataIndex)
?>
    } else {
<?        return false
?>
    }
<?    }

    ${overrideSpecifier}func writeObject(toData data: inout Data) {
        let bytecodeSignifier: UInt32 = BYTECODE_${schemaNamespace}_${className}
        data.append(UInt8(bytecodeSignifier & 0x000000FF))
        data.append(UInt8((bytecodeSignifier >> 8) & 0x000000FF))
        data.append(UInt8((bytecodeSignifier >> 16) & 0x000000FF))
        data.append(UInt8(bytecodeSignifier >> 24))
        writeAttributes(toData: &data)
        writeChildren(toData: &data)
    }

    ${overrideSpecifier}func writeAttributes(toData data: inout Data) {
?>
    bool hasAttributes = false;
    for uint32 i = 0; i < schemaClass.attributes.count; i++ {
        if !schemaClass.attributes[i].typeIsClass {
            hasAttributes = true;
            break;
        }
    }
    if hasAttributes {
<?        var bytecodeSignifier: UInt32
?>
    }
    for uint32 i = 0; i < schemaClass.attributes.count; i++ {
        SchemaAttribute attribute = schemaClass.attributes[i];
        if attribute.typeIsClass {
            continue;
        }
        string attributeName = attribute.name;
        
        // Check this value against the default value. Elide if it matches the default.
        // Lists with no default should be considered to have an empty default value.
        bool requiresList = attribute.minOccurrences < 1 || attribute.maxOccurrences > 1;
        bool hasDefaultValue = attribute.defaultValues.count > 0;
        string indent = requiresList || hasDefaultValue ? "    " : "";
        if requiresList || hasDefaultValue {
            string defaultConditional;
            if attribute.defaultValues.count == 1 {
                string defaultValue = attribute.defaultValues[0];
                if attribute.typeIsEnum {
                    defaultValue = "." + defaultValue;
                }
                defaultConditional = attributeName + " != " + defaultValue;
            } else {
                uint32 defaultListCount = hasDefaultValue ? attribute.defaultValues.count : 0;
                defaultConditional = attributeName + ".count != " + (string)defaultListCount;
                for uint32 defaultIndex = 0; defaultIndex < attribute.defaultValues.count; defaultIndex++ {
                    string defaultValue = attribute.defaultValues[defaultIndex];
                    if attribute.typeIsEnum {
                        defaultValue = "." + defaultValue;
                    }
                    defaultConditional += "\n            || " + attributeName + "[" + (string)defaultIndex + "] != " + defaultValue;
                }
            }
<?        if ${defaultConditional} {
?>
        }
        
        // Specify which variable is being written.
<?${indent}        bytecodeSignifier = BYTECODE_${schemaNamespace}_${className}_${attributeName}
${indent}        data.append(UInt8(bytecodeSignifier & 0x000000FF))
${indent}        data.append(UInt8((bytecodeSignifier >> 8) & 0x000000FF))
${indent}        data.append(UInt8((bytecodeSignifier >> 16) & 0x000000FF))
${indent}        data.append(UInt8(bytecodeSignifier >> 24))
?>
        
        // Specify the length if this is a list of variable length.
        if attribute.minOccurrences != attribute.maxOccurrences {
            // Specify the length of this list.
<?${indent}        bytecodeSignifier = UInt32(${attributeName}.count)
${indent}        data.append(UInt8(bytecodeSignifier & 0x000000FF))
${indent}        data.append(UInt8((bytecodeSignifier >> 8) & 0x000000FF))
${indent}        data.append(UInt8((bytecodeSignifier >> 16) & 0x000000FF))
${indent}        data.append(UInt8(bytecodeSignifier >> 24))
?>
        }
        
        // Specify the variable value.
        string attributeVar = requiresList ? attributeName + "Value" : attributeName;
        string typeName = attribute.typeName;
        string typeNamespace = attribute.typeNamespace;
        if requiresList {
<?${indent}        for ${attributeVar} in ${attributeName} {
?>
            indent += "    ";
        }
        
        if typeName == "uint32" {
<?${indent}        data.append(UInt8(${attributeVar} & 0x000000FF))
${indent}        data.append(UInt8((${attributeVar} >> 8) & 0x000000FF))
${indent}        data.append(UInt8((${attributeVar} >> 16) & 0x000000FF))
${indent}        data.append(UInt8(${attributeVar} >> 24))
?>
        } else if attribute.typeIsEnum ||  // Enums are UInt32.
           typeName == "int32" ||
           typeName == "float32" {
            if attribute.typeIsEnum {
<?${indent}        bytecodeSignifier = ${attributeVar}.rawValue
?>
            } else if typeName == "int32" {
 <?${indent}        bytecodeSignifier = UInt32(bitPattern: ${attributeVar})
?>
            } else {  // float32.
<?${indent}        bytecodeSignifier = ${attributeVar}.bitPattern
?>
            }
           
<?${indent}        data.append(UInt8(bytecodeSignifier & 0x000000FF))
${indent}        data.append(UInt8((bytecodeSignifier >> 8) & 0x000000FF))
${indent}        data.append(UInt8((bytecodeSignifier >> 16) & 0x000000FF))
${indent}        data.append(UInt8(bytecodeSignifier >> 24))
?>
        } else if typeName == "uint64" {
<?${indent}        data.append(UInt8(${attributeVar} & 0x00000000000000FF))
${indent}        data.append(UInt8((${attributeVar} >> 8) & 0x00000000000000FF))
${indent}        data.append(UInt8((${attributeVar} >> 16) & 0x00000000000000FF))
${indent}        data.append(UInt8((${attributeVar} >> 24) & 0x00000000000000FF))
${indent}        data.append(UInt8((${attributeVar} >> 32) & 0x00000000000000FF))
${indent}        data.append(UInt8((${attributeVar} >> 40) & 0x00000000000000FF))
${indent}        data.append(UInt8((${attributeVar} >> 48) & 0x00000000000000FF))
${indent}        data.append(UInt8(${attributeVar} >> 56))
?>
        } else if typeName == "int64" ||
                  typeName == "float64" {
            if typeName == "int64" {
<?${indent}        let bitPattern = UInt64(bitPattern: ${attributeVar})
?>
            } else {  // float64.
<?${indent}        let bitPattern: UInt64 = ${attributeVar}.bitPattern
?>
            }
<?${indent}        data.append(UInt8(bitPattern & 0x00000000000000FF))
${indent}        data.append(UInt8((bitPattern >> 8) & 0x00000000000000FF))
${indent}        data.append(UInt8((bitPattern >> 16) & 0x00000000000000FF))
${indent}        data.append(UInt8((bitPattern >> 24) & 0x00000000000000FF))
${indent}        data.append(UInt8((bitPattern >> 32) & 0x00000000000000FF))
${indent}        data.append(UInt8((bitPattern >> 40) & 0x00000000000000FF))
${indent}        data.append(UInt8((bitPattern >> 48) & 0x00000000000000FF))
${indent}        data.append(UInt8(bitPattern >> 56))
?>
        } else if typeName == "bool" {
            if attribute.defaultValues.count == 1 {
                // In the case that there's exactly 1 default value, we know this is a single bool, which is not the same as the default.
                // This means there's only a single value that it can be, which should be hard coded.
                if (bool)attribute.defaultValues[0] {
<?${indent}        data.append(0)
?>
                } else {
<?${indent}        data.append(1)
?>
                }
            } else {
<?${indent}        data.append(${attributeVar} ? 1 : 0)
?>
            }
        } else if typeName == "char" {
<?${indent}        data.append(${attributeVar})
?>
        } else if attribute.typeIsUIDReference ||
                  typeName == "string" ||
                  typeName == "UID" {
<?${indent}        for char in ${attributeVar}.utf8 {
${indent}            data.append(char)
${indent}        }
${indent}        data.append(0)
?>
        } else {
            error("Unrecognized type for attribute "+schemaNamespace+"::"+className+"::"+attributeName);
        }
        
        if requiresList {
<?${indent}    }
?>
        }
        
        if requiresList || hasDefaultValue {
<?        }
?>
        }
    }
    if schemaClass.superclass != NULL {
<?        super.writeAttributes(toData: &data)
?>
    } else if !hasAttributes {
<?        // No-op.
?>
    }
<?    }

    ${overrideSpecifier}func writeChildren(toData data: inout Data) {
?>
    bool hasChildren = false;
    for uint32 i = 0; i < schemaClass.attributes.count; i++ {
        if schemaClass.attributes[i].typeIsClass {
            hasChildren = true;
            break;
        }
    }
    if hasChildren {
<?        var bytecodeSignifier: UInt32
?>
    }
    for uint32 i = 0; i < schemaClass.attributes.count; i++ {
        SchemaAttribute attribute = schemaClass.attributes[i];
        if !attribute.typeIsClass {
            continue;
        }
        string attributeName = attribute.name;
        
        // Check this value against the default value. Elide if it matches the default.
        // Lists with no default should be considered to have an empty default value.
        bool requiresList = attribute.minOccurrences < 1 || attribute.maxOccurrences > 1;
        bool hasDefaultValue = attribute.defaultValues.count > 0;
        string indent = requiresList || hasDefaultValue ? "    " : "";
        if requiresList || hasDefaultValue {
            string defaultConditional;
            if attribute.defaultValues.count == 1 {
                defaultConditional = attributeName + " != nil";  // Class defaults are always "nil".
            } else {
                uint32 defaultListCount = hasDefaultValue ? attribute.defaultValues.count : 0;
                defaultConditional = attributeName + ".count != " + (string)defaultListCount;
                for uint32 defaultIndex = 0; defaultIndex < attribute.defaultValues.count; defaultIndex++ {
                    defaultConditional += "\n            || " + attributeName + "[" + (string)defaultIndex + "] != nil";  // Class defaults are always "nil".
                }
            }
<?        if ${defaultConditional} {
?>
        }
        
        // Specify which child is being written.
<?${indent}        bytecodeSignifier = BYTECODE_${schemaNamespace}_${className}_${attributeName}
${indent}        data.append(UInt8(bytecodeSignifier & 0x000000FF))
${indent}        data.append(UInt8((bytecodeSignifier >> 8) & 0x000000FF))
${indent}        data.append(UInt8((bytecodeSignifier >> 16) & 0x000000FF))
${indent}        data.append(UInt8(bytecodeSignifier >> 24))
?>
        
        // Specify the length if this is a list of variable length.
        if attribute.minOccurrences != attribute.maxOccurrences {
            // Specify the length of this list.
<?${indent}        bytecodeSignifier = UInt32(${attributeName}.count)
${indent}        data.append(UInt8(bytecodeSignifier & 0x000000FF))
${indent}        data.append(UInt8((bytecodeSignifier >> 8) & 0x000000FF))
${indent}        data.append(UInt8((bytecodeSignifier >> 16) & 0x000000FF))
${indent}        data.append(UInt8(bytecodeSignifier >> 24))
?>
        }
        
        // Specify the child value.
        string childVar = requiresList ? attributeName + "Value" : attributeName;
        string typeName = attribute.typeName;
        string typeNamespace = attribute.typeNamespace;
        if requiresList {
            string compactMap = attribute.typeIsClass && hasDefaultValue ? ".compactMap { $0 }" : "";
<?${indent}        for ${childVar} in ${attributeName}${compactMap} {
?>
            indent += "    ";
        }
        string unwrap = attribute.typeIsClass && hasDefaultValue ? "!" : "";
<?${indent}        ${childVar}${unwrap}.writeObject(toData: &data)
?>
        
        if requiresList {
            <?${indent}    }
?>
        }
        
        if requiresList || hasDefaultValue {
            <?        }
?>
        }
    }
    if schemaClass.superclass != NULL {
        <?        super.writeChildren(toData: &data)
?>
    } else if !hasChildren {
        <?        // No-op.
?>
    }
<?    }
?>
}
<?}
?>
