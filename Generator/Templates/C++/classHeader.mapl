#import "../../Executable/MaPLGeneratorAPI.mapl"

Schema schema = (Schema)inParameters["schema"];
SchemaClass schemaClass = (SchemaClass)inParameters["class"];

string schemaNamespace = schema.namespace;
string className = schemaClass.name;
string superclassName;
if schemaClass.superclass != "" {
    superclassName = "public " + schemaClass.superclassNamespace + "::" + schemaClass.superclass;
} else {
    superclassName = "public MaPLGeneratorSerialized, public MaPLInterface";
}

string outputDir = commandLineFlag("cppOutputDir");
outputToFile(outputDir + "/" + schemaNamespace + "/" + className + ".h");

<?// Generated by MaPLGenerator, based on the '${schemaNamespace}::${className}' schema.

#ifndef ${schemaNamespace}_${className}_h
#define ${schemaNamespace}_${className}_h

#include "${schemaNamespace}Namespace.h"
#include <vector>

namespace ${schemaNamespace} {

    class ${className} : ${superclassName} {
    public:
        // MaPLGeneratorSerialized.
        virtual void initializeWithData(uint8_t *data, size_t *dataIndex, size_t dataLength);
        virtual void writeDataToVector(std::vector<uint8_t> &data);
        
        // MaPLInterface.
        virtual MaPLParameter invokeFunction(MaPLSymbol functionSymbol, const MaPLParameter *argv, MaPLParameterCount argc);
        virtual MaPLParameter invokeSubscript(MaPLParameter index) const;
        virtual void assignProperty(MaPLSymbol propertySymbol, MaPLParameter assignedValue);
        virtual void assignSubscript(MaPLParameter index, MaPLParameter assignedValue);

        // Ivars.
?>

for uint32 attrIndex = 0; attrIndex < schemaClass.attributes.count; attrIndex++ {
    SchemaAttribute attribute = schemaClass.attributes[attrIndex];
    string attributeName = attribute.name;
    
    // Map the type of this attribute from its EaSL type to its C++ type.
    string dataType;
    bool passByReference = false;
    if attribute.typeIsUIDReference {
        dataType = "std::string";
        passByReference = true;
        string referencedType = attribute.typeNamespace + "::" + attribute.typeName;
        <?        // Refers to an object of type ${referencedType}.
?>
    } else if attribute.typeIsClass {
        dataType = attribute.typeNamespace + "::" + attribute.typeName;
        passByReference = true;
    } else if attribute.typeIsEnum {
        dataType = attribute.typeNamespace + "::" + attribute.typeName;
    } else if attribute.typeName == "float32" {
        dataType = "float";
    } else if attribute.typeName == "float64" {
        dataType = "double";
    } else if attribute.typeName == "string" || attribute.typeName == "UID" {
        dataType = "std::string";
        passByReference = true;
    } else if attribute.typeName == "bool" || attribute.typeName == "char" {
        dataType = attribute.typeName;
    } else {
        dataType = attribute.typeName + "_t";
    }
    if attribute.minOccurrences < 1 || attribute.maxOccurrences > 1 {
        dataType = "std::vector<" + dataType + ">";
        passByReference = true;
    }
    
    <?        ${dataType} ${attributeName};
?>
}
<?
    };

} /* ${schemaNamespace} namespace */

#endif /* ${schemaNamespace}_${className}_h */
?>
