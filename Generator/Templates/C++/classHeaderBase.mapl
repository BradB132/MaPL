#import "../../Executable/MaPLGeneratorAPI.mapl"

Schema schema = (Schema)inParameters["schema"];
SchemaClass schemaClass = (SchemaClass)inParameters["class"];

bool useMaPLInterface = (bool)commandLineFlag("MaPLInterface");
bool useMaPLGeneratorSerialized = (bool)commandLineFlag("MaPLGeneratorSerialized");

string schemaNamespace = schema.namespace;
string className = schemaClass.name;

string outputDir = commandLineFlag("cppOutputDir");
outputToFile(outputDir + "/" + schemaNamespace + "/" + className + "_generated.hpp");

<?// Generated by MaPLGenerator, based on the '${schemaNamespace}::${className}' schema.

#ifndef ${schemaNamespace}_${className}_generated_h
#define ${schemaNamespace}_${className}_generated_h

?>
bool isSubclass = schemaClass.superclass != NULL;
if isSubclass {
    <?#include "${schemaNamespace}/${schemaClass.superclass.name}.hpp"
?>
} else {
    if useMaPLInterface {
        <?#include "MaPLInterface.hpp"
?>
    }
    if useMaPLGeneratorSerialized {
        <?#include "MaPLGeneratorSerialized.hpp"
?>
    }
}
for uint32 attrIndex = 0; attrIndex < schemaClass.attributes.count; attrIndex++ {
    SchemaAttribute attribute = schemaClass.attributes[attrIndex];
    if attribute.annotations.contains("omit") {
        continue;
    }
    if attribute.typeIsEnum {
        <?#include "${schemaNamespace}/Enums.hpp"
?>
        break;
    }
}
for uint32 attrIndex = 0; attrIndex < schemaClass.attributes.count; attrIndex++ {
    SchemaAttribute attribute = schemaClass.attributes[attrIndex];
    if attribute.annotations.contains("omit") {
        continue;
    }
    if attribute.typeName == "string" {
        <?#include <string>
?>
        break;
    }
}
if !useMaPLInterface {
    for uint32 attrIndex = 0; attrIndex < schemaClass.attributes.count; attrIndex++ {
        SchemaAttribute attribute = schemaClass.attributes[attrIndex];
        if (attribute.minOccurrences < 1 || attribute.maxOccurrences > 1) && !attribute.annotations.contains("omit") {
        <?#include <vector>
?>
            break;
        }
    }
}
stringSet.clear();
for uint32 attrIndex = 0; attrIndex < schemaClass.attributes.count; attrIndex++ {
    SchemaAttribute attribute = schemaClass.attributes[attrIndex];
    if attribute.annotations.contains("omit") {
        continue;
    }
    if attribute.typeIsClass {
        string typeName = attribute.typeName;
        string typeNamespace = attribute.typeNamespace;
        string classKey = typeNamespace + "::" + typeName;
        SchemaClass attributeClass = schemas[typeNamespace].classes[typeName];
        if !stringSet.contains(classKey) &&
           attributeClass.descendantClasses.count == 0 &&
           attribute.defaultValues.count == 0 {
            <?#include "${typeNamespace}/${typeName}.hpp"
?>
            stringSet.insert(classKey);
        }
    }
}
if useMaPLGeneratorSerialized && schemaClass.annotations.contains("root") {
    <?#include <filesystem>
?>
}

// The "omit" annotation causes the attribute to be ignored. Instead of checking for a non-zero
// number of attributes in `schemaClass.attributes`, determine if there are any non-omitted attributes.
bool hasAttributes = false;

bool firstForwardDeclaration = true;
for uint32 attrIndex = 0; attrIndex < schemaClass.attributes.count; attrIndex++ {
    SchemaAttribute attribute = schemaClass.attributes[attrIndex];
    if attribute.annotations.contains("omit") {
        continue;
    } else {
        hasAttributes = true;
    }
    if attribute.typeIsClass {
        string typeName = attribute.typeName;
        string typeNamespace = attribute.typeNamespace;
        string classKey = typeNamespace + "::" + typeName;
        SchemaClass attributeClass = schemas[typeNamespace].classes[typeName];
        if !stringSet.contains(classKey) &&
           (attributeClass.descendantClasses.count > 0 || attribute.defaultValues.count > 0) {
            if firstForwardDeclaration {
                <?
?>
                firstForwardDeclaration = false;
            }
            <?namespace ${typeNamespace} { class ${typeName}; }
?>
            stringSet.insert(classKey);
        }
    }
}
if useMaPLGeneratorSerialized && schemaClass.annotations.contains("root") {
    if firstForwardDeclaration {
        <?
?>
        firstForwardDeclaration = false;
    }
    <?namespace ${schemaNamespace} { class ${className}; }
?>
}

string superclassDeclaration;
if isSubclass {
    superclassDeclaration = " : public " + schemaClass.superclass.namespace + "::" + schemaClass.superclass.name;
} else {
    if useMaPLGeneratorSerialized && useMaPLInterface {
        superclassDeclaration = " : public MaPLGeneratorSerialized, public MaPLInterface";
    } else if useMaPLGeneratorSerialized {
        superclassDeclaration = " : public MaPLGeneratorSerialized";
    } else if useMaPLInterface {
        superclassDeclaration = " : public MaPLInterface";
    } else {
        superclassDeclaration = "";
    }
}

<?
namespace ${schemaNamespace} {

    class ${className}_generated${superclassDeclaration} {
    public:
?>

if hasAttributes {
    <?        // Ivars.
?>
    for uint32 attrIndex = 0; attrIndex < schemaClass.attributes.count; attrIndex++ {
        SchemaAttribute attribute = schemaClass.attributes[attrIndex];
        if attribute.annotations.contains("omit") {
            continue;
        }
        bool requiresList = attribute.minOccurrences < 1 || attribute.maxOccurrences > 1;
        
        // Map the type of this attribute from its EaSL type to its C++ type.
        string dataType;
        if attribute.typeIsClass {
            dataType = attribute.typeNamespace + "::" + attribute.typeName;
            if schemas[attribute.typeNamespace].classes[attribute.typeName].descendantClasses.count > 0 ||
               attribute.defaultValues.count > 0 {
                dataType += "*";
            }
        } else if attribute.typeIsEnum {
            dataType = attribute.typeNamespace + "::" + attribute.typeName;
        } else if attribute.typeName == "float32" {
            dataType = "float";
        } else if attribute.typeName == "float64" {
            dataType = "double";
        } else if attribute.isStringType {
            dataType = "std::string";
        } else if attribute.typeName == "bool" || attribute.typeName == "char" {
            dataType = attribute.typeName;
        } else {
            dataType = attribute.typeName + "_t";
        }
        if requiresList {
            string collectionType = useMaPLInterface ? "MaPLArray" : "std::vector";
            dataType = collectionType + "<" + dataType + ">";
        }
        
        <?        ${dataType} ${attribute.name};?>
        if attribute.typeIsUIDReference {
            string referencedType = attribute.typeNamespace + "::" + attribute.typeName;
            <?  // Matches a UID on an object of type ${referencedType}.?>
        } else if attribute.typeName == "UID" {
            <?  // UID.?>
        }
        <?
?>
    }
}

<?
        ${className}_generated();
        virtual ~${className}_generated();
?>

if useMaPLGeneratorSerialized {
    if schemaClass.annotations.contains("root") {
<?
        // Convenience methods for serialization / deserialization.
        static bool readFromFile(const std::filesystem::path& filePath, ${schemaNamespace}::${className}* initializedObject);
        bool writeToFile(const std::filesystem::path& filePath);
?>
    }
<?
        // MaPLGeneratorSerialized.
        virtual bool initializeObjectWithData(uint8_t *data, size_t *dataIndex, size_t dataLength) override;
        virtual MaPLGeneratorSerializedParseStatus initializeAttributeWithData(uint8_t *data, size_t *dataIndex, size_t dataLength) override;
        virtual void writeObjectToVector(std::vector<uint8_t> &data) override;
        virtual void writeAttributesToVector(std::vector<uint8_t> &data) override;
?>
}

if useMaPLInterface {
<?
        // MaPLInterface.
        virtual MaPLParameter invokeFunction(MaPLSymbol functionSymbol, const MaPLParameter *argv, MaPLParameterCount argc) override;
        virtual MaPLParameter invokeSubscript(MaPLParameter &index) const override;
        virtual void assignProperty(MaPLSymbol propertySymbol, MaPLParameter &assignedValue) override;
        virtual void assignSubscript(MaPLParameter index, MaPLParameter &assignedValue) override;
?>
}

<?    };

} /* ${schemaNamespace} namespace */

#endif /* ${schemaNamespace}_${className}_generated_h */
?>
