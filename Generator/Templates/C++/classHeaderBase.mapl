#import "../../Executable/MaPLGeneratorAPI.mapl"

Schema schema = (Schema)inParameters["schema"];
SchemaClass schemaClass = (SchemaClass)inParameters["class"];

bool useMaPLInterface = (bool)commandLineFlag("MaPLInterface");
bool useMaPLGeneratorSerialized = (bool)commandLineFlag("MaPLGeneratorSerialized");

string schemaNamespace = schema.namespace;
string className = schemaClass.name;

string outputDir = commandLineFlag("cppOutputDir");
outputToFile(outputDir + "/" + schemaNamespace + "/" + className + "_generated.h");

<?// Generated by MaPLGenerator, based on the '${schemaNamespace}::${className}' schema.

#ifndef ${schemaNamespace}_${className}_generated_h
#define ${schemaNamespace}_${className}_generated_h

?>
bool isSubclass = schemaClass.superclass != NULL;
if isSubclass {
    string superclassName = schemaClass.superclass.name;
    <?#include "${superclassName}.h"
?>
} else {
    if useMaPLInterface {
        <?#include "../MaPLInterface.h"
?>
    }
    if useMaPLGeneratorSerialized {
        <?#include "../MaPLGeneratorSerialized.h"
?>
    }
}
for uint32 attrIndex = 0; attrIndex < schemaClass.attributes.count; attrIndex++ {
    if schemaClass.attributes[attrIndex].typeIsEnum {
        <?#include "Enums.h"
?>
        break;
    }
}
for uint32 attrIndex = 0; attrIndex < schemaClass.attributes.count; attrIndex++ {
    if schemaClass.attributes[attrIndex].typeName == "string" {
        <?#include <string>
?>
        break;
    }
}
if !useMaPLInterface {
    for uint32 attrIndex = 0; attrIndex < schemaClass.attributes.count; attrIndex++ {
        SchemaAttribute attribute = schemaClass.attributes[attrIndex];
        if attribute.minOccurrences < 1 || attribute.maxOccurrences > 1 {
        <?#include <vector>
?>
            break;
        }
    }
}

bool firstForwardDeclaration = true;
for uint32 attrIndex = 0; attrIndex < schemaClass.attributes.count; attrIndex++ {
    SchemaAttribute attribute = schemaClass.attributes[attrIndex];
    if attribute.typeIsClass {
        bool alreadyDeclaredType = false;
        for uint32 innerAttrIndex = 0; innerAttrIndex < attrIndex; innerAttrIndex++ {
            SchemaAttribute innerAttribute = schemaClass.attributes[innerAttrIndex];
            if innerAttribute.typeName == attribute.typeName && innerAttribute.typeNamespace == attribute.typeNamespace {
                alreadyDeclaredType = true;
                break;
            }
        }
        if !alreadyDeclaredType {
            if firstForwardDeclaration {
                <?
?>
                firstForwardDeclaration = false;
            }
            string typeNamespace = attribute.typeNamespace;
            string typeName = attribute.typeName;
            <?namespace ${typeNamespace} { class ${typeName}; }
?>
        }
    }
}

string superclassDeclaration;
if isSubclass {
    superclassDeclaration = " : public " + schemaClass.superclass.namespace + "::" + schemaClass.superclass.name;
} else {
    if useMaPLGeneratorSerialized && useMaPLInterface {
        superclassDeclaration = " : public MaPLGeneratorSerialized, public MaPLInterface";
    } else if useMaPLGeneratorSerialized {
        superclassDeclaration = " : public MaPLGeneratorSerialized";
    } else if useMaPLInterface {
        superclassDeclaration = " : public MaPLInterface";
    } else {
        superclassDeclaration = "";
    }
}

<?
namespace ${schemaNamespace} {

    class ${className}_generated${superclassDeclaration} {
    public:
?>

if schemaClass.attributes.count > 0 {
    <?        // Ivars.
?>
    for uint32 attrIndex = 0; attrIndex < schemaClass.attributes.count; attrIndex++ {
        SchemaAttribute attribute = schemaClass.attributes[attrIndex];
        string attributeName = attribute.name;
        bool requiresList = attribute.minOccurrences < 1 || attribute.maxOccurrences > 1;
        
        // Map the type of this attribute from its EaSL type to its C++ type.
        string dataType;
        if attribute.typeIsUIDReference {
            dataType = "std::string";
        } else if attribute.typeIsClass {
            dataType = attribute.typeNamespace + "::" + attribute.typeName + "*";
        } else if attribute.typeIsEnum {
            dataType = attribute.typeNamespace + "::" + attribute.typeName;
        } else if attribute.typeName == "float32" {
            dataType = "float";
        } else if attribute.typeName == "float64" {
            dataType = "double";
        } else if attribute.typeName == "string" || attribute.typeName == "UID" {
            dataType = "std::string";
        } else if attribute.typeName == "bool" || attribute.typeName == "char" {
            dataType = attribute.typeName;
        } else {
            dataType = attribute.typeName + "_t";
        }
        if requiresList {
            string collectionType = useMaPLInterface ? "MaPLArray" : "std::vector";
            dataType = collectionType + "<" + dataType + ">";
        }
        
        <?        ${dataType} ${attributeName};?>
        if attribute.typeIsUIDReference {
            string referencedType = attribute.typeNamespace + "::" + attribute.typeName;
            <?  // Matches a UID on an object of type ${referencedType}.?>
        } else if attribute.typeName == "UID" {
            <?  // UID.?>
        }
        <?
?>
    }
}

<?
        ${className}_generated();
        virtual ~${className}_generated();
?>

if useMaPLGeneratorSerialized {
<?
        // MaPLGeneratorSerialized.
        virtual bool initializeObjectWithData(uint8_t *data, size_t *dataIndex, size_t dataLength) override;
        virtual bool initializeAttributeWithData(uint8_t *data, size_t *dataIndex, size_t dataLength) override;
        virtual void writeObjectToVector(std::vector<uint8_t> &data) override;
        virtual void writeAttributesToVector(std::vector<uint8_t> &data) override;
?>
}

if useMaPLInterface {
<?
        // MaPLInterface.
        virtual MaPLParameter invokeFunction(MaPLSymbol functionSymbol, const MaPLParameter *argv, MaPLParameterCount argc) override;
        virtual MaPLParameter invokeSubscript(MaPLParameter &index) const override;
        virtual void assignProperty(MaPLSymbol propertySymbol, MaPLParameter &assignedValue) override;
        virtual void assignSubscript(MaPLParameter index, MaPLParameter &assignedValue) override;
?>
}

<?    };

} /* ${schemaNamespace} namespace */

#endif /* ${schemaNamespace}_${className}_generated_h */
?>
