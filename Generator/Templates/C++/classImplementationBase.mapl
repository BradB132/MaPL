#import "../../Executable/MaPLGeneratorAPI.mapl"

Schema schema = (Schema)inParameters["schema"];
SchemaClass schemaClass = (SchemaClass)inParameters["class"];

string schemaNamespace = schema.namespace;
string className = schemaClass.name;

string outputDir = commandLineFlag("cppOutputDir");
outputToFile(outputDir + "/" + schemaNamespace + "/" + className + "_generated.cpp");

bool useMaPLInterface = (bool)commandLineFlag("MaPLInterface");
bool useMaPLGeneratorSerialized = (bool)commandLineFlag("MaPLGeneratorSerialized");

<?// Generated by MaPLGenerator, based on the '${schemaNamespace}::${className}' schema.

#include "${schemaNamespace}/${className}_generated.hpp"
?>

stringSet.clear();
for uint32 attrIndex = 0; attrIndex < schemaClass.attributes.count; attrIndex++ {
    SchemaAttribute attribute = schemaClass.attributes[attrIndex];
    if attribute.typeIsClass {
        string typeName = attribute.typeName;
        string typeNamespace = attribute.typeNamespace;
        string classKey = typeNamespace + "::" + typeName;
        
        SchemaClass attributeClass = schemas[typeNamespace].classes[typeName];
        if !stringSet.contains(classKey) &&
           (attributeClass.descendantClasses.count > 0 || attribute.defaultValues.count > 0) {
            <?#include "${typeNamespace}/${typeName}.hpp"
?>
            stringSet.insert(classKey);
        }
        for uint32 descendantIndex = 0; descendantIndex < attributeClass.descendantClasses.count; descendantIndex++ {
            SchemaClass descendant = attributeClass.descendantClasses[descendantIndex];
            typeName = descendant.name;
            typeNamespace = descendant.namespace;
            classKey = "include:" + typeNamespace + "::" + typeName;
            if !stringSet.contains(classKey) {
                <?#include "${typeNamespace}/${typeName}.hpp"
?>
                stringSet.insert(classKey);
            }
        }
    }
}

if useMaPLInterface {
    <?#include "${commandLineFlag("MaPLSymbolPrefix")}.h"  // Use MaPLCompiler to generate this symbol file.
?>
}

if useMaPLGeneratorSerialized {
    for uint32 attrIndex = 0; attrIndex < schemaClass.attributes.count; attrIndex++ {
        if schemaClass.attributes[attrIndex].typeName == "string" {
            <?#include <cstring>
?>
            break;
        }
    }
    if schemaClass.annotations.contains("root") {
        <?#include "${schemaNamespace}/${className}.hpp"
#include <fstream>
?>
    }
}

<?
${schemaNamespace}::${className}_generated::${className}_generated()?>
for uint32 attrIndex = 0; attrIndex < schemaClass.attributes.count; attrIndex++ {
    if schemaClass.attributes[attrIndex].defaultValues.count > 0 {
        <? : ?>
        break;
    }
}
bool firstDefaultAttribute = true;
for uint32 attrIndex = 0; attrIndex < schemaClass.attributes.count; attrIndex++ {
    SchemaAttribute attribute = schemaClass.attributes[attrIndex];
    if attribute.defaultValues.count > 0 {
        string attributeValue;
        if attribute.defaultValues.count == 1 {
            string defaultValue = attribute.defaultValues[0];
            if attribute.typeIsEnum {
                attributeValue = attribute.typeName + "_" + defaultValue;
            } else {
                attributeValue = defaultValue;
            }
        } else {
            attributeValue = "{ ";
            for uint32 defaultIndex = 0; defaultIndex < attribute.defaultValues.count; defaultIndex++ {
                string defaultValue = attribute.defaultValues[defaultIndex];
                if attribute.typeIsEnum {
                    attributeValue += attribute.typeName + "_" + defaultValue;
                } else {
                    attributeValue += defaultValue;
                }
                if defaultIndex < attribute.defaultValues.count-1 {
                    attributeValue +=  ", ";
                }
            }
            attributeValue += " }";
        }
        if !firstDefaultAttribute {
            <?,?>
        }
        firstDefaultAttribute = false;
        <?
    ${attribute.name}(${attributeValue})?>
    }
}
<? {
}

${schemaNamespace}::${className}_generated::~${className}_generated() {
?>
for uint32 attrIndex = 0; attrIndex < schemaClass.attributes.count; attrIndex++ {
    SchemaAttribute attribute = schemaClass.attributes[attrIndex];
    if attribute.typeIsClass &&
       (schemas[attribute.typeNamespace].classes[attribute.typeName].descendantClasses.count > 0 || attribute.defaultValues.count > 0) {
        if attribute.minOccurrences < 1 || attribute.maxOccurrences > 1 {
            string dataType = attribute.typeNamespace + "::" + attribute.typeName;
            string collectionIvar = useMaPLInterface ? "._backingVector" : "";
<?    for (${dataType} *value : ${attribute.name}${collectionIvar}) {
        delete value;
    }
?>
        } else {
<?    delete ${attribute.name};
?>
        }
    }
}
<?}

?>

if useMaPLGeneratorSerialized {
    if schemaClass.annotations.contains("root") {
<?bool ${schemaNamespace}::${className}_generated::readFromFile(const std::filesystem::path& filePath, ${schemaNamespace}::${className}* initializedObject) {
    std::ifstream inputStream(filePath, std::ios::binary|std::ios::ate);
    if (!inputStream) {
        return false;
    }
    size_t byteLength = inputStream.tellg();
    if (!byteLength) {
        return false;
    }
    inputStream.seekg(0, std::ios::beg);
    u_int8_t bytecode[byteLength];
    inputStream.read((char *)bytecode, byteLength);
    if (inputStream.rdstate()) {
        return false;
    }
    uint16_t endianShort = 1;
    uint8_t endianByte = *(uint8_t *)&endianShort;
    if (endianByte != bytecode[0]) {
        return false;
    }
    size_t dataIndex = 1;
    return initializedObject->initializeObjectWithData(bytecode, &dataIndex, byteLength) && dataIndex == byteLength;
}

bool ${schemaNamespace}::${className}_generated::writeToFile(const std::filesystem::path& filePath) {
    std::vector<uint8_t> outputBytes;
    uint16_t endianShort = 1;
    uint8_t endianByte = *(uint8_t *)&endianShort;
    outputBytes.push_back(endianByte);
    this->writeObjectToVector(outputBytes);
    std::ofstream outputStream(filePath, std::ios::binary);
    if (!outputStream) {
        return false;
    }
    outputStream.write((char *)&(outputBytes[0]), outputBytes.size());
    return !outputStream.bad();
}

?>
    }
<?/**
 * MaPLGeneratorSerialized.
 */
bool ${schemaNamespace}::${className}_generated::initializeObjectWithData(uint8_t *data, size_t *dataIndex, size_t dataLength) {
    if (*dataIndex+sizeof(uint32_t) > dataLength ||
        *((uint32_t*)(data+*dataIndex)) != BYTECODE_${schemaNamespace}_${className}_BEGIN) {
        return false;
    }
    *dataIndex += sizeof(uint32_t);
    MaPLGeneratorSerializedParseStatus result = MaPLGeneratorSerializedParseStatus_success;
    while (result == MaPLGeneratorSerializedParseStatus_success) {
        result = initializeAttributeWithData(data, dataIndex, dataLength);
    }
    return result == MaPLGeneratorSerializedParseStatus_completed;
}

MaPLGeneratorSerializedParseStatus ${schemaNamespace}::${className}_generated::initializeAttributeWithData(uint8_t *data, size_t *dataIndex, size_t dataLength) {
?>
    if schemaClass.attributes.count > 0 {
<?    if (*dataIndex+sizeof(uint32_t) > dataLength) {
        return MaPLGeneratorSerializedParseStatus_error;
    }
    uint32_t nextAttributeName = *((uint32_t*)(data+*dataIndex));
    *dataIndex += sizeof(uint32_t);
    switch (nextAttributeName) {
        case BYTECODE_${schemaNamespace}_${className}_END:
            return MaPLGeneratorSerializedParseStatus_completed;
?>
        for uint32 i = 0; i < schemaClass.attributes.count; i++ {
            SchemaAttribute attribute = schemaClass.attributes[i];
            string attributeName = attribute.name;
<?        case BYTECODE_${schemaNamespace}_${className}_${attributeName}: {
?>
            // Handle lists of values.
            bool requiresList = attribute.minOccurrences < 1 || attribute.maxOccurrences > 1;
            string indent = requiresList ? "    " : "";
            if requiresList {
                string listLength;
                if attribute.minOccurrences != attribute.maxOccurrences {  // Variable length.
<?            if (*dataIndex+sizeof(uint32_t) > dataLength) {
                return MaPLGeneratorSerializedParseStatus_error;
            }
            uint32_t ${attributeName}Length = *((uint32_t*)(data+*dataIndex));
            *dataIndex += sizeof(uint32_t);
?>
                    listLength = attributeName + "Length";
                } else {  // Fixed length
                    listLength = (string)attribute.minOccurrences;
                }
                string collectionIvar = useMaPLInterface ? "._backingVector" : "";
<?            ${attributeName}${collectionIvar}.clear();
            ${attributeName}${collectionIvar}.reserve(${listLength});
            for (uint32_t ${attributeName}Index = 0; ${attributeName}Index < ${listLength}; ${attributeName}Index++) {
?>
            }

            // Read ivar values.
            string typeName = attribute.typeName;
            if attribute.typeIsClass {
                string typeNamespace = attribute.typeNamespace;
                SchemaClass attributeClass = schemas[attribute.typeNamespace].classes[typeName];
                bool hasDescendants = attributeClass.descendantClasses.count > 0;
                bool classIsPointer = hasDescendants || attribute.defaultValues.count > 0;
                if hasDescendants {
<?${indent}            if (*dataIndex+sizeof(uint32_t) > dataLength) {
${indent}                return MaPLGeneratorSerializedParseStatus_error;
${indent}            }
${indent}            ${typeNamespace}::${typeName}* createdObject;
${indent}            switch (*((uint32_t*)(data+*dataIndex))) {
${indent}                case BYTECODE_${typeNamespace}_${typeName}_BEGIN:
${indent}                    createdObject = new ${typeNamespace}::${typeName}();
${indent}                    break;
?>
                    for uint32 descendantIndex = 0; descendantIndex < attributeClass.descendantClasses.count; descendantIndex++ {
                        SchemaClass descendant = attributeClass.descendantClasses[descendantIndex];
<?${indent}                case BYTECODE_${descendant.namespace}_${descendant.name}_BEGIN:
${indent}                    createdObject = new ${descendant.namespace}::${descendant.name}();
${indent}                    break;
?>
                    }
<?${indent}                default:
${indent}                    return MaPLGeneratorSerializedParseStatus_error;
${indent}            }
?>
                } else if classIsPointer {
<?${indent}            ${typeNamespace}::${typeName}* createdObject = new ${typeNamespace}::${typeName}();
?>
                }
                
                if requiresList {
                    string collectionIvar = useMaPLInterface ? "._backingVector" : "";
                    if classIsPointer {
<?${indent}            ${attributeName}${collectionIvar}.push_back(createdObject);
?>
                    } else {
<?${indent}            ${typeNamespace}::${typeName}& createdObject = ${attributeName}${collectionIvar}.emplace_back();
?>
                    }
                } else if classIsPointer {
<?${indent}            ${attributeName} = createdObject;
?>
                }
                string objectToMember = classIsPointer ? "->" : ".";
                string objectName = requiresList ? "createdObject" : attributeName;
                
<?${indent}            if (!${objectName}${objectToMember}initializeObjectWithData(data, dataIndex, dataLength)) {
${indent}                return MaPLGeneratorSerializedParseStatus_error;
${indent}            }
?>
            } else if attribute.typeIsUIDReference ||
                      typeName == "string" ||
                      typeName == "UID" {
<?${indent}            size_t stringLength = strlen((char*)(data+*dataIndex))+1;
${indent}            if (*dataIndex+stringLength > dataLength) {
${indent}                return MaPLGeneratorSerializedParseStatus_error;
${indent}            }
?>
                if requiresList {
                    string collectionIvar = useMaPLInterface ? "._backingVector" : "";
<?${indent}            ${attributeName}${collectionIvar}.push_back((char*)(data+*dataIndex));
?>
                } else {
<?${indent}            ${attributeName} = (char*)(data+*dataIndex);
?>
                }
<?${indent}            *dataIndex += stringLength;
?>
            } else {
                string primitiveType;
                if typeName == "int32" {
                    primitiveType = "int32_t";
                } else if typeName == "uint32" {
                    primitiveType = "uint32_t";
                } else if typeName == "int64" {
                    primitiveType = "int64_t";
                } else if typeName == "uint64" {
                    primitiveType = "uint64_t";
                } else if typeName == "float32" {
                    primitiveType = "float";
                } else if typeName == "float64" {
                    primitiveType = "double";
                } else if typeName == "bool" || typeName == "char" {
                    primitiveType = "uint8_t";
                } else if attribute.typeIsEnum {
                    primitiveType = attribute.typeNamespace + "::" + typeName;
                }
<?${indent}            if (*dataIndex+sizeof(${primitiveType}) > dataLength) {
${indent}                return MaPLGeneratorSerializedParseStatus_error;
${indent}            }
?>
                if requiresList {
                    string collectionIvar = useMaPLInterface ? "._backingVector" : "";
<?${indent}            ${attributeName}${collectionIvar}.push_back(*((${primitiveType}*)(data+*dataIndex)));
?>
                } else {
<?${indent}            ${attributeName} = *((${primitiveType}*)(data+*dataIndex));
?>
                }
<?${indent}            *dataIndex += sizeof(${primitiveType});
?>
            }

            if requiresList {
<?            }
?>
            }
<?        }
            return MaPLGeneratorSerializedParseStatus_success;
?>
        }
<?        default:
?>
        if schemaClass.superclass != NULL {
<?            *dataIndex -= sizeof(uint32_t);
?>
        }
<?            break;
    }
?>
    }
    if schemaClass.superclass != NULL {
<?    return ${schemaClass.superclass.namespace}::${schemaClass.superclass.name}::initializeAttributeWithData(data, dataIndex, dataLength);
?>
    } else {
<?    return MaPLGeneratorSerializedParseStatus_error;
?>
    }
<?}

void ${schemaNamespace}::${className}_generated::writeObjectToVector(std::vector<uint8_t> &data) {
    uint32_t bytecodeSignifier = BYTECODE_${schemaNamespace}_${className}_BEGIN;
    data.insert(data.end(), { *((uint8_t *)&bytecodeSignifier), *((uint8_t *)&bytecodeSignifier+1), *((uint8_t *)&bytecodeSignifier+2), *((uint8_t *)&bytecodeSignifier+3) });
    writeAttributesToVector(data);
    bytecodeSignifier = BYTECODE_${schemaNamespace}_${className}_END;
    data.insert(data.end(), { *((uint8_t *)&bytecodeSignifier), *((uint8_t *)&bytecodeSignifier+1), *((uint8_t *)&bytecodeSignifier+2), *((uint8_t *)&bytecodeSignifier+3) });
}

void ${schemaNamespace}::${className}_generated::writeAttributesToVector(std::vector<uint8_t> &data) {
?>
    bool hasAttributes = false;
    if schemaClass.attributes.count > 0 {
        <?    uint32_t bytecodeSignifier;
?>
    }
    for uint32 i = 0; i < schemaClass.attributes.count; i++ {
        SchemaAttribute attribute = schemaClass.attributes[i];
        string attributeName = attribute.name;
        
        // Check this value against the default value. Elide if it matches the default.
        // Lists with no default should be considered to have an empty default value.
        bool requiresList = attribute.minOccurrences < 1 || attribute.maxOccurrences > 1;
        bool hasDefaultValue = attribute.defaultValues.count > 0;
        string indent = requiresList || hasDefaultValue ? "    " : "";
        if requiresList || hasDefaultValue {
            string defaultConditional;
            if attribute.defaultValues.count == 1 {
                string defaultValue = attribute.defaultValues[0];
                if attribute.typeIsEnum {
                    defaultValue = attribute.typeNamespace + "::" + attribute.typeName + "_" + defaultValue;
                }
                defaultConditional = attributeName + " != " + defaultValue;
            } else {
                string collectionIvar = useMaPLInterface ? "._backingVector" : "";
                uint32 defaultListCount = hasDefaultValue ? attribute.defaultValues.count : 0;
                defaultConditional = attributeName + collectionIvar + ".size() != " + (string)defaultListCount;
                for uint32 defaultIndex = 0; defaultIndex < attribute.defaultValues.count; defaultIndex++ {
                    string defaultValue = attribute.defaultValues[defaultIndex];
                    if attribute.typeIsEnum {
                        defaultValue = attribute.typeNamespace + "::" + attribute.typeName + "_" + defaultValue;
                    }
                    defaultConditional += "\n        || " + attributeName + collectionIvar + "[" + (string)defaultIndex + "] != " + defaultValue;
                }
            }
<?    if (${defaultConditional}) {
?>
        }
        
        // Specify which variable is being written.
<?${indent}    bytecodeSignifier = BYTECODE_${schemaNamespace}_${className}_${attributeName};
${indent}    data.insert(data.end(), { *((uint8_t *)&bytecodeSignifier), *((uint8_t *)&bytecodeSignifier+1), *((uint8_t *)&bytecodeSignifier+2), *((uint8_t *)&bytecodeSignifier+3) });
?>
        
        // Specify the length if this is a list of variable length.
        if attribute.minOccurrences != attribute.maxOccurrences {
            // Specify the length of this list.
            string collectionIvar = useMaPLInterface ? "._backingVector" : "";
            <?${indent}    bytecodeSignifier = (uint32_t)${attributeName}${collectionIvar}.size();
${indent}    data.insert(data.end(), { *((uint8_t *)&bytecodeSignifier), *((uint8_t *)&bytecodeSignifier+1), *((uint8_t *)&bytecodeSignifier+2), *((uint8_t *)&bytecodeSignifier+3) });
?>
        }
        
        // Specify the variable value.
        string attributeVar = requiresList ? attributeName + "Value" : attributeName;
        string typeName = attribute.typeName;
        string typeNamespace = attribute.typeNamespace;
        bool hasDescendants = attribute.typeIsClass && schemas[typeNamespace].classes[typeName].descendantClasses.count > 0;
        if requiresList {
            string collectionIvar = useMaPLInterface ? "._backingVector" : "";
            string referenceType = attribute.typeIsClass && !hasDescendants ? "&" : "";
<?${indent}    for (auto${referenceType} ${attributeVar} : ${attributeName}${collectionIvar}) {
?>
            indent += "    ";
        }
        
        if attribute.typeIsClass {
            string objectToMember = hasDescendants ? "->" : ".";
<?${indent}    ${attributeVar}${objectToMember}writeObjectToVector(data);
?>
        } else {  // Primitives.
            if attribute.typeIsEnum ||  // Enums are uint32_t.
               typeName == "int32" ||
               typeName == "uint32" ||
               typeName == "float32" {
<?${indent}    data.insert(data.end(), { *((uint8_t *)&${attributeVar}), *((uint8_t *)&${attributeVar}+1), *((uint8_t *)&${attributeVar}+2), *((uint8_t *)&${attributeVar}+3) });
?>
            } else if typeName == "int64" ||
                      typeName == "uint64" ||
                      typeName == "float64" {
<?${indent}    data.insert(data.end(), { *((uint8_t *)&${attributeVar}), *((uint8_t *)&${attributeVar}+1), *((uint8_t *)&${attributeVar}+2), *((uint8_t *)&${attributeVar}+3), *((uint8_t *)&${attributeVar}+4), *((uint8_t *)&${attributeVar}+5), *((uint8_t *)&${attributeVar}+6), *((uint8_t *)&${attributeVar}+7) });
?>
            } else if typeName == "bool" {
                if attribute.defaultValues.count == 1 {
                    // In the case that there's exactly 1 default value, we know this is a single bool, which is not the same as the default.
                    // This means there's only a single value that it can be, which should be hard coded.
                    if (bool)attribute.defaultValues[0] {
<?${indent}    data.push_back(0);
?>
                    } else {
<?${indent}    data.push_back(1);
?>
                    }
                } else {
<?${indent}    data.push_back(${attributeVar} ? 1 : 0);
?>
                }
            } else if typeName == "char" {
<?${indent}    data.push_back(${attributeVar});
?>
            } else if attribute.typeIsUIDReference ||
                      typeName == "string" ||
                      typeName == "UID" {
<?${indent}    for (size_t i = 0; i < ${attributeVar}.length(); i++) {
${indent}        data.push_back(${attributeVar}[i]);
${indent}    }
${indent}    data.push_back(0);
?>
            } else {
                error("Unrecognized type for attribute "+schemaNamespace+"::"+className+"::"+attributeName);
            }
        }
        
        if requiresList {
            <?${indent}}
?>
        }
        
        if requiresList || hasDefaultValue {
            <?    }
?>
        }
    }
    if schemaClass.superclass != NULL {
        <?    ${schemaClass.superclass.namespace}::${schemaClass.superclass.name}::writeAttributesToVector(data);
?>
    } else if schemaClass.attributes.count == 0 {
        <?    // No-op.
?>
    }
<?}

?>
}

if useMaPLInterface {
    string symbolPrefix = commandLineFlag("MaPLSymbolPrefix");
<?/**
 * MaPLInterface.
 */
MaPLParameter ${schemaNamespace}::${className}_generated::invokeFunction(MaPLSymbol functionSymbol, const MaPLParameter *argv, MaPLParameterCount argc) {
?>
    if schemaClass.attributes.count > 0 {
<?    if (argc > 0) {
        return MaPLUninitialized();
    }
    switch (functionSymbol) {
?>
        for uint32 i = 0; i < schemaClass.attributes.count; i++ {
            SchemaAttribute attribute = schemaClass.attributes[i];
            string functionName;
            bool isString = attribute.typeIsUIDReference || attribute.typeName == "string" || attribute.typeName == "UID";
            bool isList = attribute.minOccurrences < 1 || attribute.maxOccurrences > 1;
            bool isInlineClass = attribute.typeIsClass &&
                                 schemas[attribute.typeNamespace].classes[attribute.typeName].descendantClasses.count == 0 &&
                                 attribute.defaultValues.count == 0;
            string ivarPrefix = isList || isInlineClass ? "&" : "";
            string ivarSuffix = "";
            if isList || attribute.typeIsClass {
                functionName = "MaPLPointer";
            } else if isString {
                functionName = "MaPLStringByReference";
                ivarSuffix = ".c_str()";
            } else if attribute.typeIsEnum || attribute.typeName == "uint32" {
                functionName = "MaPLUint32";
            } else if attribute.typeName == "int32" {
                functionName = "MaPLInt32";
            } else if attribute.typeName == "bool" {
                functionName = "MaPLBool";
            } else if attribute.typeName == "int64" {
                functionName = "MaPLInt64";
            } else if attribute.typeName == "uint64" {
                functionName = "MaPLUint64";
            } else if attribute.typeName == "float32" {
                functionName = "MaPLFloat32";
            } else if attribute.typeName == "float64" {
                functionName = "MaPLFloat64";
            } else { // Char.
                functionName = "MaPLChar";
            }
            string attributeName = attribute.name;
<?        case ${symbolPrefix}_${schemaNamespace}_${className}_${attributeName}:
            return ${functionName}(${ivarPrefix}${attributeName}${ivarSuffix});
?>
        }
<?        default:
            break;
    }
?>
    }
    
    if schemaClass.superclass == NULL {
<?    return MaPLUninitialized();
?>
    } else {
<?    return ${schemaClass.superclass.namespace}::${schemaClass.superclass.name}::invokeFunction(functionSymbol, argv, argc);
?>
    }
<?}

MaPLParameter ${schemaNamespace}::${className}_generated::invokeSubscript(MaPLParameter &index) const {
    return MaPLUninitialized();  // This object doesn't respond to subscripts.
}

void ${schemaNamespace}::${className}_generated::assignProperty(MaPLSymbol propertySymbol, MaPLParameter &assignedValue) {
?>
    bool hasWriteableProperties = false;
    for uint32 i = 0; i < schemaClass.attributes.count; i++ {
        SchemaAttribute attribute = schemaClass.attributes[i];
        // Arrays and classes are readonly.
        if !attribute.typeIsClass && attribute.minOccurrences == 1 && attribute.maxOccurrences == 1 {
            hasWriteableProperties = true;
            break;
        }
    }
    if hasWriteableProperties {
<?    switch (propertySymbol) {
?>
        for uint32 i = 0; i < schemaClass.attributes.count; i++ {
            SchemaAttribute attribute = schemaClass.attributes[i];
            if attribute.typeIsClass || attribute.minOccurrences < 1 || attribute.maxOccurrences > 1 {
                continue;  // Arrays and classes are readonly.
            }
            string attributeName = attribute.name;
            string typeDescriptor;
            string typeCast = "";
            if attribute.typeIsUIDReference || attribute.typeName == "UID" {
                typeDescriptor = "string";
            } else if attribute.typeIsEnum {
                typeDescriptor = "uint32";
                typeCast = "(" + schemaNamespace + "::" + attribute.typeName + ")";
            } else if attribute.typeName == "bool" {
                typeDescriptor = "boolean";
            } else {
                // All other types match the `typeName`.
                typeDescriptor = attribute.typeName;
            }
<?        case ${symbolPrefix}_${schemaNamespace}_${className}_${attributeName}:
            if (assignedValue.dataType != MaPLDataType_${typeDescriptor}) {
                return;
            }
            ${attributeName} = ${typeCast}assignedValue.${typeDescriptor}Value;
?>
        }
<?        default:
            break;
    }
?>
    }

    if schemaClass.superclass != NULL {
<?    return ${schemaClass.superclass.namespace}::${schemaClass.superclass.name}::assignProperty(propertySymbol, assignedValue);
?>
    } else if !hasWriteableProperties {
<?    // No-op.
?>
    }
<?}

void ${schemaNamespace}::${className}_generated::assignSubscript(MaPLParameter index, MaPLParameter &assignedValue) {
    // No-op. This object doesn't respond to subscripts.
}
?>
}
