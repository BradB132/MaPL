#import "../../Executable/MaPLGeneratorAPI.mapl"

string outputDir = commandLineFlag("cppOutputDir");
outputToFile(outputDir + "/MaPLInterface.hpp");

<?// Generated by MaPLGenerator.

#ifndef MaPLInterface_h
#define MaPLInterface_h

#include <vector>

#include "MaPLRuntime.h"

/**
 * Functions that implement all MaPLGenerator-created script APIs.
 */
MaPLParameter MaPLGenerator_invokeFunction(void *invokedOnPointer, MaPLSymbol functionSymbol, const MaPLParameter *argv, MaPLParameterCount argc);
MaPLParameter MaPLGenerator_invokeSubscript(void *invokedOnPointer, MaPLParameter index);
void MaPLGenerator_assignProperty(void *invokedOnPointer, MaPLSymbol propertySymbol, MaPLParameter assignedValue);
void MaPLGenerator_assignSubscript(void *invokedOnPointer, MaPLParameter index, MaPLParameter assignedValue);
        
/**
 * Abstract class that can be used for any MaPL API.
 */
class MaPLInterface {
public:
    virtual MaPLParameter invokeFunction(MaPLSymbol functionSymbol, const MaPLParameter *argv, MaPLParameterCount argc) = 0;
    virtual MaPLParameter invokeSubscript(MaPLParameter &index) const = 0;
    virtual void assignProperty(MaPLSymbol propertySymbol, MaPLParameter &assignedValue) = 0;
    virtual void assignSubscript(MaPLParameter index, MaPLParameter &assignedValue) = 0;
};

/**
 * Array class that implements MaPLInterface and can contain the MaPLRuntime types.
 */
template <typename T>
class MaPLArray : public MaPLInterface {
public:
    MaPLArray() {
    }
    
    MaPLArray(std::initializer_list<T> list) : _backingVector(list) {
    }
    
    virtual MaPLParameter invokeFunction(MaPLSymbol functionSymbol, const MaPLParameter *argv, MaPLParameterCount argc) {
        if (argc == 0) {
            // Assume this is attempting to check the length of the array.
            return MaPLUint32((uint32_t)_backingVector.size());
        }
        return MaPLUninitialized();
    }
    
    virtual MaPLParameter invokeSubscript(MaPLParameter &index) const {
        const T &value = _backingVector[index.uint32Value];
        if constexpr (std::is_same_v<T, u_int8_t>) {
            return MaPLChar(value);
        }
        if constexpr (std::is_same_v<T, int32_t>) {
            return MaPLInt32(value);
        }
        if constexpr (std::is_same_v<T, int64_t>) {
            return MaPLInt64(value);
        }
        if constexpr (std::is_same_v<T, u_int32_t>) {
            return MaPLUint32(value);
        }
        if constexpr (std::is_same_v<T, u_int64_t>) {
            return MaPLUint64(value);
        }
        if constexpr (std::is_same_v<T, float>) {
            return MaPLFloat32(value);
        }
        if constexpr (std::is_same_v<T, double>) {
            return MaPLFloat64(value);
        }
        if constexpr (std::is_same_v<T, bool>) {
            return MaPLBool(value);
        }
        if constexpr (std::is_same_v<T, std::string>) {
            return MaPLStringByValue(value.c_str());
        }
        if constexpr (std::is_pointer_v<T>) {
            return MaPLPointer(value);
        }
        return MaPLUninitialized();
    }
    
    virtual void assignProperty(MaPLSymbol propertySymbol, MaPLParameter &assignedValue) {
        // No-op. No assignable properties.
    }

    virtual void assignSubscript(MaPLParameter index, MaPLParameter &assignedValue) {
        if (index.dataType != MaPLDataType_uint32) {
            return;
        }
        if constexpr (std::is_same_v<T, u_int8_t>) {
            _backingVector[index.uint32Value] = assignedValue.charValue;
        }
        if constexpr (std::is_same_v<T, int32_t>) {
            _backingVector[index.uint32Value] = assignedValue.int32Value;
        }
        if constexpr (std::is_same_v<T, int64_t>) {
            _backingVector[index.uint32Value] = assignedValue.int64Value;
        }
        if constexpr (std::is_same_v<T, u_int32_t>) {
            _backingVector[index.uint32Value] = assignedValue.uint32Value;
        }
        if constexpr (std::is_same_v<T, u_int64_t>) {
            _backingVector[index.uint32Value] = assignedValue.uint64Value;
        }
        if constexpr (std::is_same_v<T, float>) {
            _backingVector[index.uint32Value] = assignedValue.float32Value;
        }
        if constexpr (std::is_same_v<T, double>) {
            _backingVector[index.uint32Value] = assignedValue.float64Value;
        }
        if constexpr (std::is_same_v<T, bool>) {
            _backingVector[index.uint32Value] = assignedValue.booleanValue;
        }
        if constexpr (std::is_same_v<T, std::string>) {
            _backingVector[index.uint32Value] = assignedValue.stringValue;
        }
        if constexpr (std::is_pointer_v<T>) {
            _backingVector[index.uint32Value] = (T)assignedValue.pointerValue;
        }
    }
    std::vector<T> _backingVector;
};

#endif /* MaPLInterface_h */
?>

outputToFile(outputDir + "/MaPLInterface.cpp");

<?
#include "MaPLInterface.hpp"
#include "MaPLSymbols.h"  // Use MaPLCompiler to generate this symbol file.

MaPLParameter MaPLGenerator_invokeFunction(void *invokedOnPointer, MaPLSymbol functionSymbol, const MaPLParameter *argv, MaPLParameterCount argc) {
    if (invokedOnPointer) {
        MaPLInterface *maplInterface = static_cast<MaPLInterface *>(invokedOnPointer);
        return maplInterface->invokeFunction(functionSymbol, argv, argc);
    }
?>
bool hasEnum = false;
for uint32 schemaIndex = 0; schemaIndex < schemas.count; schemaIndex++ {
    Schema schema = schemas[schemaIndex];
    if schema.enums.count > 0 {
        hasEnum = true;
        break;
    }
}
if hasEnum {
    string symbolPrefix = commandLineFlag("MaPLSymbolPrefix");
<?    // Enums.
    switch (functionSymbol) {
?>
    for uint32 schemaIndex = 0; schemaIndex < schemas.count; schemaIndex++ {
        Schema schema = schemas[schemaIndex];
        string namespace = schema.namespace;
        for uint32 i = 0; i < schema.enums.count; i++ {
            SchemaEnum enum = schema.enums[i];
            string enumName = enum.name;
            for uint32 j = 0; j < enum.cases.count; j++ {
<?        case ${symbolPrefix}_GLOBAL_${namespace}_${enumName}_${enum.cases[j].name}:
            return MaPLUint32(${j});
?>
            }
        }
    }
<?    }
?>
}
<?    return MaPLUninitialized();
}

MaPLParameter MaPLGenerator_invokeSubscript(void *invokedOnPointer, MaPLParameter index) {
    MaPLInterface *maplInterface = static_cast<MaPLInterface *>(invokedOnPointer);
    return maplInterface->invokeSubscript(index);
}

void MaPLGenerator_assignProperty(void *invokedOnPointer, MaPLSymbol propertySymbol, MaPLParameter assignedValue) {
    MaPLInterface *maplInterface = static_cast<MaPLInterface *>(invokedOnPointer);
    maplInterface->assignProperty(propertySymbol, assignedValue);
}

void MaPLGenerator_assignSubscript(void *invokedOnPointer, MaPLParameter index, MaPLParameter assignedValue) {
    MaPLInterface *maplInterface = static_cast<MaPLInterface *>(invokedOnPointer);
    maplInterface->assignSubscript(index, assignedValue);
}
?>
